<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ã‚¹ãƒ©ã‚¤ãƒ æˆ¦äº‰</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Mochiy+Pop+One&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Mochiy+Pop+One', sans-serif;
            background-color: #f0f9ff;
            color: #1e3a8a;
            user-select: none;
        }
        .screen {
            display: none;
            width: 100%;
            height: 100vh;
            overflow: hidden;
            position: fixed;
            top: 0;
            left: 0;
        }
        .screen.active {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        .btn {
            background-color: #3b82f6;
            color: white;
            padding: 1rem 2rem;
            border-radius: 9999px;
            font-size: 1.25rem;
            font-weight: bold;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
            transition: all 0.2s ease-in-out;
            border-bottom: 4px solid #1d4ed8;
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.1);
        }
        .btn:active {
            transform: translateY(2px);
            box-shadow: none;
            border-bottom-width: 2px;
        }
        .btn-secondary {
            background-color: #fbbf24;
            border-bottom-color: #d97706;
        }
        .btn-special {
            background-color: #ec4899;
            border-bottom-color: #be185d;
        }
        .btn-disabled {
            background-color: #d1d5db;
            color: #4b5563;
            border-bottom-color: #6b7280;
            cursor: not-allowed;
            opacity: 0.7;
        }
        .card {
            background: white;
            border-radius: 1.5rem;
            padding: 2rem;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            border: 4px solid #93c5fd;
        }
        /* æ–°ã—ã„ã‚¹ãƒ©ã‚¤ãƒ ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        .slime-icon {
            width: 80px;
            height: 80px;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            flex-shrink: 0;
        }
        .slime-body {
            width: 70px;
            height: 60px;
            border-radius: 50% / 60% 60% 40% 40%;
            position: relative;
            border: 3px solid rgba(0,0,0,0.2);
        }
        .slime-eyes {
            position: absolute;
            bottom: 25px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
        }
        .slime-eye {
            width: 6px;
            height: 8px;
            background-color: #2c3e50;
            border-radius: 50%;
        }
        .slot {
            width: 80px;
            height: 100px;
            background: #bfdbfe;
            border: 4px solid #60a5fa;
            border-radius: 1rem;
            overflow: hidden;
            position: relative;
        }
        .slot-reel {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: top 0.1s linear;
        }
        .slot-item {
            font-size: 3rem;
            height: 100px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .hp-bar-container {
            width: 100%;
            height: 20px;
            background-color: #e0e7ff;
            border-radius: 9999px;
            border: 2px solid #93c5fd;
            overflow: hidden;
        }
        .hp-bar {
            height: 100%;
            background: linear-gradient(to right, #4ade80, #22c55e);
            border-radius: 9999px;
            transition: width 0.5s ease-out;
        }
        /* Gacha Animation */
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
            20%, 40%, 60%, 80% { transform: translateX(5px); }
        }
        @keyframes glow {
            0% { transform: scale(0); opacity: 0.5; }
            50% { opacity: 1; }
            100% { transform: scale(3); opacity: 0; }
        }
        .gacha-chest {
            font-size: 150px;
            cursor: pointer;
        }
        .shaking {
            animation: shake 0.5s linear;
        }
        .gacha-light {
            position: absolute;
            width: 100px;
            height: 100px;
            background: radial-gradient(circle, rgba(255,255,0,1) 0%, rgba(255,255,255,0) 70%);
            border-radius: 50%;
            display: none;
        }
        .glowing {
            display: block;
            animation: glow 1.5s ease-out forwards;
        }
        .slot-item.matched {
            transform: scale(1.2);
            background-color: rgba(251, 191, 36, 0.7); /* amber-400 with opacity */
            border-radius: 10px;
            transition: transform 0.3s ease-out, background-color 0.3s ease-out;
        }
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
    </style>
</head>
<body class="bg-blue-50">

    <!-- ã‚²ãƒ¼ãƒ å…¨ä½“ã®ã‚³ãƒ³ãƒ†ãƒŠ -->
    <div id="game-container" class="w-full h-screen max-w-lg mx-auto bg-blue-100 shadow-2xl relative">

        <!-- ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ç”»é¢ -->
        <div id="loading-screen" class="screen active p-8">
            <h1 class="text-5xl font-bold text-blue-800 mb-4">ã‚¹ãƒ©ã‚¤ãƒ æˆ¦äº‰</h1>
            <p class="text-xl text-blue-600">Now Loading...</p>
        </div>

        <!-- ãƒ‘ãƒ¼ãƒˆãƒŠãƒ¼ã‚¹ãƒ©ã‚¤ãƒ é¸æŠç”»é¢ -->
        <div id="partner-select-screen" class="screen p-4 bg-blue-100">
            <div class="card w-full max-w-md text-center">
                <h2 class="text-3xl font-bold mb-4">æœ€åˆã®ç›¸æ£’ã‚’é¸ã¼ã†ï¼</h2>
                <div id="partner-options" class="grid grid-cols-3 gap-4 my-6">
                    <!-- JSã§é¸æŠè‚¢ã‚’ç”Ÿæˆ -->
                </div>
                <button id="confirm-partner-btn" class="btn btn-secondary w-full">ã“ã®å­ã«æ±ºã‚ã‚‹ï¼</button>
            </div>
        </div>

        <!-- ãƒ›ãƒ¼ãƒ ç”»é¢ -->
        <div id="home-screen" class="screen p-8 space-y-6">
            <h1 class="text-5xl font-bold text-blue-800">ã‚¹ãƒ©ã‚¤ãƒ æˆ¦äº‰</h1>
            <div class="flex flex-col space-y-5 w-full max-w-xs">
                <button onclick="showScreen('play-mode-screen')" class="btn">ãƒãƒˆãƒ«</button>
                <button onclick="showScreen('party-formation-screen')" class="btn">ãƒ‘ãƒ¼ãƒ†ã‚£ç·¨æˆ</button>
                <button onclick="showScreen('collection-screen')" class="btn">å›³é‘‘ã‚’è¦‹ã‚‹</button>
                <button onclick="showScreen('gacha-screen')" class="btn">ã‚¬ãƒãƒ£ã‚‹</button>
                <button onclick="showScreen('how-to-play-screen')" class="btn">éŠã³æ–¹</button>
            </div>
        </div>

        <!-- ãƒ‘ãƒ¼ãƒ†ã‚£ç·¨æˆç”»é¢ -->
        <div id="party-formation-screen" class="screen p-4">
            <div class="w-full max-w-md h-[90vh] flex flex-col">
                <div class="card flex-grow overflow-hidden flex flex-col">
                    <h2 class="text-2xl font-bold text-center mb-4">ãƒ‘ãƒ¼ãƒ†ã‚£ç·¨æˆ</h2>
                    <p class="text-center text-sm mb-2">ä¸‹ã®ã‚¹ãƒ©ã‚¤ãƒ ã‚’ã‚¿ãƒƒãƒ—ã—ã¦ãƒ‘ãƒ¼ãƒ†ã‚£ã‚’å…¥ã‚Œæ›¿ãˆã‚ˆã†ï¼</p>
                    <div class="bg-blue-100 p-2 rounded-lg mb-4">
                        <div class="flex justify-between items-center mb-2 px-2">
                             <h3 class="font-bold text-center">ç¾åœ¨ã®ãƒ‘ãƒ¼ãƒ†ã‚£</h3>
                             <p id="party-total-stats" class="text-sm font-bold"></p>
                        </div>
                        <div id="current-party-display" class="grid grid-cols-3 gap-2 min-h-[120px]">
                            <!-- JSã§ç”Ÿæˆ -->
                        </div>
                    </div>
                    <div class="flex-grow overflow-y-auto bg-blue-50 p-2 rounded-lg">
                         <h3 class="font-bold text-center mb-2">æ‰‹æŒã¡ã®ã‚¹ãƒ©ã‚¤ãƒ </h3>
                        <div id="owned-slimes-list" class="grid grid-cols-4 gap-2">
                            <!-- JSã§ç”Ÿæˆ -->
                        </div>
                    </div>
                </div>
                <div class="text-center mt-4">
                     <button onclick="showScreen('home-screen')" class="btn btn-secondary">æˆ»ã‚‹</button>
                </div>
            </div>
        </div>

        <!-- ãƒ—ãƒ¬ã‚¤ãƒ¢ãƒ¼ãƒ‰é¸æŠç”»é¢ -->
        <div id="play-mode-screen" class="screen p-8 space-y-6">
            <h2 class="text-4xl font-bold">ãƒ—ãƒ¬ã‚¤ãƒ¢ãƒ¼ãƒ‰</h2>
            <div class="flex flex-col space-y-5 w-full max-w-xs">
                <button onclick="showScreen('story-map-screen')" class="btn">ã‚¹ãƒˆãƒ¼ãƒªãƒ¼ãƒ¢ãƒ¼ãƒ‰</button>
                <button id="online-mode-btn" class="btn">ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ãƒ¢ãƒ¼ãƒ‰</button>
                <p id="online-status-text" class="text-center text-sm mt-2"></p>
            </div>
            <button onclick="showScreen('home-screen')" class="btn btn-secondary mt-8">æˆ»ã‚‹</button>
        </div>

        <!-- ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ãƒ­ãƒ“ãƒ¼ç”»é¢ -->
        <div id="online-lobby-screen" class="screen p-8 space-y-6">
            <h2 class="text-4xl font-bold">ã‚ªãƒ³ãƒ©ã‚¤ãƒ³å¯¾æˆ¦</h2>
            <div id="matching-status" class="card w-full max-w-md text-center">
                 <p id="lobby-message" class="text-xl mb-6">å¯¾æˆ¦ç›¸æ‰‹ã‚’æ¢ã—ã¾ã™</p>
                 <button id="start-matching-btn" class="btn" onclick="startMatching()">ãƒãƒƒãƒãƒ³ã‚°é–‹å§‹</button>
                 <div id="matching-loader" class="hidden mx-auto loader"></div>
                 <p id="your-id-text" class="text-xs mt-4 break-all"></p>
            </div>
             <button onclick="cancelMatching(); showScreen('play-mode-screen');" class="btn btn-secondary mt-8">æˆ»ã‚‹</button>
        </div>

        <!-- ã‚¹ãƒˆãƒ¼ãƒªãƒ¼ãƒãƒƒãƒ—ç”»é¢ -->
        <div id="story-map-screen" class="screen p-4">
            <h2 class="text-3xl font-bold text-center my-4">ã‚¹ãƒˆãƒ¼ãƒªãƒ¼</h2>
            <div id="stage-list" class="grid grid-cols-5 gap-4 overflow-y-auto h-[70vh] p-4 bg-white/50 rounded-2xl">
                <!-- ã‚¹ãƒ†ãƒ¼ã‚¸ã¯JSã§ç”Ÿæˆ -->
            </div>
            <div class="text-center mt-4">
                <button onclick="showScreen('play-mode-screen')" class="btn btn-secondary">æˆ»ã‚‹</button>
            </div>
        </div>
        
        <!-- ãƒãƒˆãƒ«ç”»é¢ -->
        <div id="battle-screen" class="screen p-4 justify-between bg-green-200">
            <div id="enemy-area" class="w-full text-center">
                 <p id="enemy-name" class="text-sm font-bold truncate"></p>
                <div class="flex justify-center space-x-2"></div>
                <div class="w-full max-w-xs mx-auto mt-2">
                    <div class="hp-bar-container"><div id="enemy-hp-bar" class="hp-bar"></div></div>
                    <p id="enemy-hp-text" class="text-sm font-bold"></p>
                </div>
            </div>

            <div id="battle-message" class="text-center font-bold text-2xl h-16 flex items-center justify-center p-2 bg-white/50 rounded-lg"></div>

            <div id="player-area" class="w-full text-center">
                 <p id="player-name" class="text-sm font-bold truncate"></p>
                 <div class="w-full max-w-xs mx-auto mb-2">
                    <div class="hp-bar-container"><div id="player-hp-bar" class="hp-bar"></div></div>
                    <p id="player-hp-text" class="text-sm font-bold"></p>
                </div>
                <!-- ãƒ¬ã‚¸ã‚§ãƒ³ãƒ‰ãƒ‘ãƒ¯ãƒ¼ã‚²ãƒ¼ã‚¸ã‚’è¿½åŠ  -->
                <div id="legend-power-container" class="w-full max-w-xs mx-auto mt-1">
                    <div class="hp-bar-container border-yellow-400">
                        <div id="legend-power-bar" class="hp-bar bg-gradient-to-r from-purple-400 via-pink-500 to-red-500" style="width: 0%;"></div>
                    </div>
                    <p id="legend-power-text" class="text-sm font-bold text-pink-600 text-center">ãƒ¬ã‚¸ã‚§ãƒ³ãƒ‰ãƒ‘ãƒ¯ãƒ¼: 0 / 100</p>
                </div>
                <div class="flex justify-center space-x-2 mt-2"></div>
            </div>

            <div id="battle-controls" class="w-full flex flex-col items-center">
                <!-- ã‚¹ãƒ­ãƒƒãƒˆãƒã‚·ãƒ³ -->
                <div id="slot-machine-area" class="w-full flex-col items-center p-4 bg-white/70 rounded-2xl hidden">
                    <div class="flex space-x-4">
                        <div class="slot"><div class="slot-reel" id="reel1"></div></div>
                        <div class="slot"><div class="slot-reel" id="reel2"></div></div>
                        <div class="slot"><div class="slot-reel" id="reel3"></div></div>
                    </div>
                    <button id="stop-btn" class="btn mt-4">ã‚¹ãƒˆãƒƒãƒ—ï¼</button>
                </div>
                <!-- ã‚¢ã‚¯ã‚·ãƒ§ãƒ³é¸æŠ -->
                <div id="battle-actions-area" class="w-full flex justify-center space-x-4 p-4">
                    <button id="attack-btn" class="btn">ã‚¹ãƒ­ãƒƒãƒˆæ”»æ’ƒ</button>
                    <button id="special-btn" class="btn btn-special">ã¨ãã—ã‚…ã®ã†ã‚Šã‚‡ã</button>
                </div>
                <!-- ç‰¹æ®Šèƒ½åŠ›é¸æŠ -->
                <div id="special-select-area" class="w-full flex flex-col items-center p-2 bg-white/70 rounded-2xl hidden space-y-2">
                    <!-- JSã§ç”Ÿæˆ -->
                </div>
            </div>

            <div id="mash-battle-modal" class="absolute inset-0 bg-black/50 hidden items-center justify-center">
                <div class="card text-center">
                    <h3 class="text-3xl font-bold">é€£æ‰“å‹è² ï¼</h3>
                    <p class="my-4">ãƒœã‚¿ãƒ³ã‚’é€£æ‰“ã—ã¦å…ˆè¡Œã‚’æ±ºã‚ã‚ï¼</p>
                    <div id="mash-timer" class="text-5xl font-bold my-4">3</div>
                    <button id="mash-btn" class="btn w-40 h-40 rounded-full text-3xl">é€£æ‰“ï¼</button>
                </div>
            </div>
            
            <div id="battle-result-modal" class="absolute inset-0 bg-black/50 hidden items-center justify-center">
                <div class="card text-center">
                    <h3 id="result-title" class="text-5xl font-bold"></h3>
                    <p id="result-rewards" class="my-6 text-xl"></p>
                    <button id="result-close-btn" class="btn btn-secondary">OK</button>
                </div>
            </div>
        </div>

        <!-- å›³é‘‘ç”»é¢ -->
        <div id="collection-screen" class="screen p-4">
            <h2 class="text-3xl font-bold text-center my-4">ã‚¹ãƒ©ã‚¤ãƒ å›³é‘‘</h2>
            <div id="collection-grid" class="grid grid-cols-4 gap-2 overflow-y-auto h-[70vh] p-2 bg-white/50 rounded-2xl"></div>
            <div class="text-center mt-4">
                <button onclick="showScreen('home-screen')" class="btn btn-secondary">æˆ»ã‚‹</button>
            </div>
        </div>

        <!-- ã‚¬ãƒãƒ£ç”»é¢ -->
        <div id="gacha-screen" class="screen flex-col p-8 space-y-6">
             <h2 class="text-4xl font-bold">ã‚¬ãƒãƒ£</h2>
             <div class="card w-full max-w-md text-center">
                 <p class="text-xl">ã‚³ã‚¤ãƒ³: <span id="gacha-coin-count">0</span></p>
                 <div class="my-6 space-y-4">
                     <button id="gacha-single-btn" class="btn w-full">1å›ã‚¬ãƒãƒ£ã‚‹ (10ã‚³ã‚¤ãƒ³)</button>
                     <button id="gacha-multi-btn" class="btn w-full">10å›ã‚¬ãƒãƒ£ã‚‹ (80ã‚³ã‚¤ãƒ³)</button>
                 </div>
             </div>
             <button onclick="showScreen('home-screen')" class="btn btn-secondary mt-8">æˆ»ã‚‹</button>
        </div>

        <!-- ã‚¬ãƒãƒ£ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”»é¢ -->
        <div id="gacha-animation-screen" class="screen">
            <div class="relative flex justify-center items-center">
                <div class="gacha-chest">ğŸ</div>
                <div class="gacha-light"></div>
            </div>
        </div>

         <!-- ã‚¬ãƒãƒ£çµæœãƒ¢ãƒ¼ãƒ€ãƒ« -->
        <div id="gacha-result-modal" class="absolute inset-0 bg-black/50 hidden items-center justify-center p-4">
            <div class="card w-full max-w-lg text-center">
                <h3 class="text-3xl font-bold mb-4">ã‚¬ãƒãƒ£çµæœ</h3>
                <div id="gacha-result-grid" class="grid grid-cols-3 sm:grid-cols-5 gap-2 my-4"></div>
                <button onclick="document.getElementById('gacha-result-modal').style.display='none'" class="btn btn-secondary">é–‰ã˜ã‚‹</button>
            </div>
        </div>

        <!-- éŠã³æ–¹ç”»é¢ -->
        <div id="how-to-play-screen" class="screen p-4">
             <div class="card w-full max-w-md h-[80vh] overflow-y-auto">
                 <h2 class="text-3xl font-bold text-center mb-4">éŠã³æ–¹</h2>
                 <div class="space-y-4 text-blue-900">
                    <p><strong>1. ãƒãƒˆãƒ«:</strong> ãƒãƒˆãƒ«ã¯ã€Œã‚¹ãƒ­ãƒƒãƒˆæ”»æ’ƒã€ã¨ã€Œã¨ãã—ã‚…ã®ã†ã‚Šã‚‡ãã€ã‚’ä½¿ã„åˆ†ã‘ã¦æˆ¦ã†ãï¼</p>
                    <p><strong>2. å…ˆè¡Œå¾Œæ”»:</strong> ãƒãƒˆãƒ«é–‹å§‹æ™‚ã®é€£æ‰“å‹è² ã§å…ˆè¡Œãƒ»å¾Œæ”»ãŒæ±ºã¾ã‚‹ï¼</p>
                    <p><strong>3. ã‚¹ãƒ­ãƒƒãƒˆæ”»æ’ƒ:</strong> æƒã£ãŸçµµæŸ„ã§ãƒ€ãƒ¡ãƒ¼ã‚¸ãŒå¤‰ã‚ã‚‹ï¼é˜²å¾¡æ™‚ã‚‚åŒã˜ãƒ«ãƒ¼ãƒ«ã§ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’è»½æ¸›ã§ãã‚‹ãã€‚æ”»æ’ƒã™ã‚‹ã¨ãƒ¬ã‚¸ã‚§ãƒ³ãƒ‰ãƒ‘ãƒ¯ãƒ¼ãŒæºœã¾ã‚‹ï¼</p>
                    <ul class="list-disc list-inside bg-blue-100 p-2 rounded-lg">
                        <li>1å€‹ã‚‚æƒã‚ãªã„: æ”»æ’ƒåŠ› x 1å€ / ãƒ€ãƒ¡ãƒ¼ã‚¸ãã®ã¾ã¾</li>
                        <li>2å€‹æƒã†: æ”»æ’ƒåŠ› x 1.8å€ / ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ 9/10 ã«è»½æ¸›</li>
                        <li>3å€‹æƒã†: æ”»æ’ƒåŠ› x 2.5å€ / ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ 6/10 ã«è»½æ¸›</li>
                    </ul>
                    <p><strong>4. ã¨ãã—ã‚…ã®ã†ã‚Šã‚‡ã:</strong> ãƒ¬ã‚¸ã‚§ãƒ³ãƒ‰ãƒ‘ãƒ¯ãƒ¼ãŒ100ã¾ã§æºœã¾ã‚‹ã¨ä½¿ãˆã‚‹ã‚ˆã†ã«ãªã‚‹ãï¼ã‚¹ãƒ©ã‚¤ãƒ ã”ã¨ã«é•ã†å¼·åŠ›ãªèƒ½åŠ›ã ï¼</p>
                    <p><strong>5. ãƒ€ãƒ¡ãƒ¼ã‚¸è¨ˆç®—:</strong> æœ€çµ‚çš„ãªãƒ€ãƒ¡ãƒ¼ã‚¸ã‹ã‚‰ã€ç›¸æ‰‹ã®é˜²å¾¡åŠ›Ã·3ã‚’å¼•ã„ãŸå€¤ãŒå®Ÿéš›ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ã«ãªã‚‹ã€‚</p>
                    <p><strong>6. å‹åˆ©:</strong> ç›¸æ‰‹ã®HPã‚’0ã«ã—ãŸã‚‰å‹åˆ©ï¼ã‚¹ãƒˆãƒ¼ãƒªãƒ¼ã‚’é€²ã‚ã¦ã€æ–°ã—ã„ã‚¹ãƒ©ã‚¤ãƒ ã‚„ã‚³ã‚¤ãƒ³ã‚’æ‰‹ã«å…¥ã‚Œã‚ˆã†ï¼</p>
                 </div>
             </div>
             <div class="text-center mt-4">
                <button onclick="showScreen('home-screen')" class="btn btn-secondary">æˆ»ã‚‹</button>
            </div>
        </div>
    </div>

    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getFirestore, collection, addDoc, query, where, getDocs, doc, onSnapshot, updateDoc, deleteDoc, serverTimestamp, writeBatch } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";

        let db, auth;
        let unsubscribeMatch = null; 
        let localUnsubscribe = null;

        async function checkFirebaseStatus() {
            const onlineBtn = document.getElementById('online-mode-btn');
            const statusText = document.getElementById('online-status-text');

            onlineBtn.classList.add('btn-disabled');
            statusText.textContent = 'ã‚µãƒ¼ãƒãƒ¼ã«æ¥ç¶šã§ãã¾ã›ã‚“';
            statusText.style.color = 'red';
            onlineBtn.onclick = null;

            try {
                const firebaseConfig = {
                    apiKey: "AIzaSyA2SS_petftf_G5Dty4tJeQ9WYOt5_bXPI",
                    authDomain: "slimesensous.firebaseapp.com",
                    projectId: "slimesensous",
                    storageBucket: "slimesensous.firebasestorage.app",
                    messagingSenderId: "431777125771",
                    appId: "1:431777125771:web:e463caf55efdb5530b4b8e",
                    measurementId: "G-4DPQX55X16"
                };

                 if (!firebaseConfig.apiKey) {
                    throw new Error("Firebase config is missing apiKey.");
                }

                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        onlineBtn.classList.remove('btn-disabled');
                        onlineBtn.onclick = () => {
                             showScreen('online-lobby-screen');
                             document.getElementById('your-id-text').textContent = `ã‚ãªãŸã®ID: ${user.uid}`;
                        };
                        statusText.textContent = 'ã‚µãƒ¼ãƒãƒ¼ã«æ¥ç¶šæ¸ˆã¿';
                        statusText.style.color = 'green';
                    } else {
                        onlineBtn.classList.add('btn-disabled');
                        statusText.textContent = 'ã‚µãƒ¼ãƒãƒ¼ã«æ¥ç¶šã§ãã¾ã›ã‚“ (èªè¨¼å¤±æ•—)';
                        statusText.style.color = 'red';
                        onlineBtn.onclick = null;
                    }
                });
                
                await signInAnonymously(auth);

            } catch (error) {
                console.error("Firebase connection failed:", error);
                statusText.textContent = 'ç¾åœ¨ã¯ã‚µãƒ¼ãƒãƒ¼ã«æ¥ç¶šã§ãã¾ã›ã‚“ (åˆæœŸåŒ–å¤±æ•—)';
            }
        }

        // --- ã‚ªãƒ³ãƒ©ã‚¤ãƒ³å¯¾æˆ¦ãƒ­ã‚¸ãƒƒã‚¯ (æ”¹ä¿®) ---
        async function updateMatchInFirestore(updateData) {
            if (gameState.onlineMatchId) {
                const matchRef = doc(db, "matches", gameState.onlineMatchId);
                await updateDoc(matchRef, updateData);
            }
        }

        window.startMatching = async () => {
            if (player.party.length === 0) {
                alert('ã‚ªãƒ³ãƒ©ã‚¤ãƒ³å¯¾æˆ¦ã«ã¯ãƒ‘ãƒ¼ãƒ†ã‚£ç·¨æˆãŒå¿…è¦ã§ã™ã€‚'); return;
            }
            const matchingBtn = document.getElementById('start-matching-btn');
            matchingBtn.classList.add('hidden');
            document.getElementById('matching-loader').classList.remove('hidden');
            document.getElementById('lobby-message').textContent = 'å¯¾æˆ¦ç›¸æ‰‹ã‚’æ¢ã—ã¦ã„ã¾ã™...';

            const matchesRef = collection(db, "matches");
            const q = query(matchesRef, where("status", "==", "waiting"));
            const querySnapshot = await getDocs(q);
            
            let matchFound = false;
            if (!querySnapshot.empty) {
                for (const d of querySnapshot.docs) {
                    if (d.data().player1_uid !== auth.currentUser.uid) {
                        matchFound = true;
                        await joinMatch(d.id);
                        break;
                    }
                }
            }

            if (!matchFound) {
                await createMatch();
            }
        };

        const createMatch = async () => {
             try {
                const matchRef = await addDoc(collection(db, "matches"), {
                    player1_uid: auth.currentUser.uid,
                    player1_party: player.party,
                    player2_uid: null,
                    player2_party: null,
                    status: 'waiting',
                    createdAt: serverTimestamp(),
                    turn: null,
                    phase: null,
                    lastAction: null,
                    winner: null,
                });
                listenToMatch(matchRef.id);
            } catch (e) {
                console.error("Error creating match: ", e);
                cancelMatching();
            }
        };

        const joinMatch = async (matchId) => {
            try {
                const matchRef = doc(db, "matches", matchId);
                const batch = writeBatch(db);
                batch.update(matchRef, {
                    player2_uid: auth.currentUser.uid,
                    player2_party: player.party,
                    status: 'active',
                    turn: 'mash', // ãƒãƒƒãƒãƒ³ã‚°æˆåŠŸã€é€£æ‰“å‹è² ã¸
                });
                await batch.commit();
                listenToMatch(matchId);
            } catch(e) {
                console.error("Error joining match:", e);
                cancelMatching();
            }
        };
        
        const listenToMatch = (matchId) => {
            if (localUnsubscribe) localUnsubscribe(); // å‰ã®ãƒªã‚¹ãƒŠãƒ¼ã‚’è§£é™¤
            gameState.onlineMatchId = matchId;
            const matchRef = doc(db, "matches", matchId);
            localUnsubscribe = onSnapshot(matchRef, (doc) => {
                const matchData = doc.data();
                if (!matchData || matchData.status === 'canceled') {
                    if (gameState.battle) { // ãƒãƒˆãƒ«ä¸­ã«ç›¸æ‰‹ãŒåˆ‡æ–­
                        alert("ç›¸æ‰‹ãŒå¯¾æˆ¦ã‹ã‚‰é›¢è„±ã—ã¾ã—ãŸã€‚");
                        endBattle();
                    } else {
                        cancelMatching();
                    }
                    return;
                }

                if (matchData.status === 'active' && !gameState.battle) {
                    startOnlineBattle(matchData, matchId);
                } else if (gameState.battle) {
                    syncGameState(matchData);
                }
            });
        };

        window.cancelMatching = async () => {
            if (localUnsubscribe) {
                localUnsubscribe();
                localUnsubscribe = null;
            }
            if (gameState.onlineMatchId) {
                const matchRef = doc(db, "matches", gameState.onlineMatchId);
                await updateDoc(matchRef, { status: 'canceled' }).catch(()=>{});
                gameState.onlineMatchId = null;
            }
            const matchingBtn = document.getElementById('start-matching-btn');
            matchingBtn.classList.remove('hidden');
            document.getElementById('matching-loader').classList.add('hidden');
            document.getElementById('lobby-message').textContent = 'å¯¾æˆ¦ç›¸æ‰‹ã‚’æ¢ã—ã¾ã™';
        };

        const startOnlineBattle = (matchData, matchId) => {
            const isPlayer1 = matchData.player1_uid === auth.currentUser.uid;
            
            gameState.battle = {
                online: true, isPlayer1, matchId,
                playerTeam: isPlayer1 ? matchData.player1_party : matchData.player2_party,
                enemyTeam: isPlayer1 ? matchData.player2_party : matchData.player1_party,
                playerTotalStats: calculateTeamStats(isPlayer1 ? matchData.player1_party : matchData.player2_party),
                enemyTotalStats: calculateTeamStats(isPlayer1 ? matchData.player2_party : matchData.player1_party),
                turn: matchData.turn, phase: 'attack',
                playerLegendPower: 0, legendPowerMax: 100,
                lastAction: null,
            };
            gameState.battle.playerTotalStats.currentHp = gameState.battle.playerTotalStats.hp;
            gameState.battle.enemyTotalStats.currentHp = gameState.battle.enemyTotalStats.hp;

            document.getElementById('player-name').textContent = `ã‚ãªãŸ`;
            document.getElementById('enemy-name').textContent = `ã‚ã„ã¦`;
            
            setupBattleUI();
            showScreen('battle-screen');
            
            if (matchData.turn === 'mash') {
                 startMashBattle();
            } else {
                syncGameState(matchData);
            }
        };

        function syncGameState(matchData) {
            if (!gameState.battle || !matchData) return;
            const battle = gameState.battle;
            
            // HPã‚„ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’åŒæœŸ
            const myKey = battle.isPlayer1 ? 'player1' : 'player2';
            const enemyKey = battle.isPlayer1 ? 'player2' : 'player1';
            
            if(matchData[myKey+'_currentHp'] !== undefined) battle.playerTotalStats.currentHp = matchData[myKey+'_currentHp'];
            if(matchData[enemyKey+'_currentHp'] !== undefined) battle.enemyTotalStats.currentHp = matchData[enemyKey+'_currentHp'];
            if(matchData[myKey+'_legendPower'] !== undefined) battle.playerLegendPower = matchData[myKey+'_legendPower'];
            
            battle.turn = matchData.turn;
            battle.phase = matchData.phase;
            battle.lastAction = matchData.lastAction;
            
            updateHpBars();
            updateLegendPowerBar();

            if (matchData.winner) {
                endBattle();
                return;
            }

            // UIã®æ›´æ–°
            if (battle.turn === auth.currentUser.uid) { // è‡ªåˆ†ã®ã‚¿ãƒ¼ãƒ³
                 if (battle.phase === 'defense') {
                    setBattleMessage(`ç›¸æ‰‹ãŒæ”»æ’ƒã—ã¦ããŸï¼ (${battle.lastAction.matchCount}å€‹) é˜²å¾¡ã—ã‚ï¼`);
                    document.getElementById('slot-machine-area').style.display = 'flex';
                    startSlotMachine();
                 } else { // attack phase
                    setBattleMessage('ã‚ãªãŸã®ã‚¿ãƒ¼ãƒ³ï¼');
                    document.getElementById('battle-actions-area').style.display = 'flex';
                    document.getElementById('slot-machine-area').style.display = 'none';
                    document.getElementById('special-select-area').style.display = 'none';
                 }
            } else { // ç›¸æ‰‹ã®ã‚¿ãƒ¼ãƒ³
                setBattleMessage('ç›¸æ‰‹ã®ã‚¿ãƒ¼ãƒ³...');
                document.getElementById('battle-actions-area').style.display = 'none';
                document.getElementById('slot-machine-area').style.display = 'none';
                document.getElementById('special-select-area').style.display = 'none';
            }
        }


        // --- ã‚²ãƒ¼ãƒ ãƒ­ã‚¸ãƒƒã‚¯ (æ—¢å­˜) ---

        const slimeTypeColors = {
            'åŸºæœ¬': '#a3e635', 'ç«': '#f97316', 'æ°´': '#38bdf8', 'é¢¨': '#34d399', 
            'åœ°': '#a16207', 'å…‰': '#facc15', 'é—‡': '#a21caf', 'ãƒ¡ã‚¿ãƒ«': '#9ca3af', 
            'ã‚¢ãƒ³ãƒ‡ãƒƒãƒ‰': '#7c3aed', 'è‡ªç„¶': '#22c55e', 'é­”æ³•': '#ec4899', 
            'æ©Ÿæ¢°': '#64748b', 'ç‰¹æ®Š': '#d946ef', 'ä¼èª¬': 'linear-gradient(45deg, #fde047, #f97316, #ec4899, #8b5cf6)', 
            'ç¥': 'linear-gradient(45deg, #e5e7eb, #fefce8, #e5e7eb)'
        };
        const slotItems = ['ğŸ”¥', 'ğŸ’§', 'ğŸŒ¿', 'ğŸ”©', 'ğŸ’€'];
        
        let allSlimes = [];

        function generateSlimeDatabase() {
            const slimes = [
                // åŸºæœ¬ç¨®
                { no: 1, name: 'ã‚¹ãƒ©ã‚¤ãƒ ', hp: 100, atk: 10, def: 10, type: 'åŸºæœ¬', rarity: 'N', ability: { name: 'ä½“å½“ãŸã‚Š', desc: 'æ•µå˜ä½“ã«å°ãƒ€ãƒ¡ãƒ¼ã‚¸', type: 'damage', power: 0.8 } },
                { no: 2, name: 'ãƒ“ãƒƒã‚°ã‚¹ãƒ©ã‚¤ãƒ ', hp: 300, atk: 25, def: 20, type: 'åŸºæœ¬', rarity: 'R', ability: { name: 'ã·ã‚‹ã·ã‚‹ãƒ—ãƒ¬ã‚¹', desc: 'æ•µå˜ä½“ã«ä¸­ãƒ€ãƒ¡ãƒ¼ã‚¸', type: 'damage', power: 1.2 } },
                { no: 3, name: 'ã‚­ãƒ³ã‚°ã‚¹ãƒ©ã‚¤ãƒ ', hp: 1000, atk: 80, def: 70, type: 'åŸºæœ¬', rarity: 'SR', ability: { name: 'ç‹ã®å·ä»¤', desc: 'å‘³æ–¹å…¨ä½“ã®æ”»æ’ƒåŠ›ã‚¢ãƒƒãƒ—', type: 'buff_atk', power: 1.2, turns: 3 } },
                { no: 4, name: 'ã‚¨ãƒ³ãƒšãƒ©ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ ', hp: 3200, atk: 250, def: 220, type: 'åŸºæœ¬', rarity: 'SSR', ability: { name: 'çš‡å¸ã®å¨å³', desc: 'å‘³æ–¹å…¨ä½“ã®é˜²å¾¡åŠ›ã‚¢ãƒƒãƒ—', type: 'buff_def', power: 1.3, turns: 3 } },
                // ç«å±æ€§
                { no: 12, name: 'ãƒ•ã‚¡ã‚¤ã‚¢ã‚¹ãƒ©ã‚¤ãƒ ', hp: 150, atk: 20, def: 12, type: 'ç«', rarity: 'N', ability: { name: 'ãƒ•ã‚¡ã‚¤ã‚¢ãƒœãƒ¼ãƒ«', desc: 'æ•µå˜ä½“ã«ç«ã®å°ãƒ€ãƒ¡ãƒ¼ã‚¸', type: 'damage', power: 1.0 } },
                { no: 13, name: 'ãƒã‚°ãƒã‚¹ãƒ©ã‚¤ãƒ ', hp: 500, atk: 60, def: 80, type: 'ç«', rarity: 'R', ability: { name: 'ç«å‚·ä»˜ä¸', desc: 'æ•µå˜ä½“ã«å¤§ãƒ€ãƒ¡ãƒ¼ã‚¸', type: 'damage', power: 1.5 } },
                // æ°´å±æ€§
                { no: 20, name: 'ã‚¢ã‚¯ã‚¢ã‚¹ãƒ©ã‚¤ãƒ ', hp: 180, atk: 15, def: 18, type: 'æ°´', rarity: 'N', ability: { name: 'ã‚¹ãƒ—ãƒ©ãƒƒã‚·ãƒ¥', desc: 'æ•µå˜ä½“ã«æ°´ã®å°ãƒ€ãƒ¡ãƒ¼ã‚¸', type: 'damage', power: 1.0 } },
                { no: 21, name: 'ãƒ’ãƒ¼ãƒªãƒ³ã‚°ã‚¹ãƒ©ã‚¤ãƒ ', hp: 300, atk: 10, def: 40, type: 'æ°´', rarity: 'R', ability: { name: 'ãƒ’ãƒ¼ãƒ«', desc: 'å‘³æ–¹å˜ä½“ã®HPã‚’å°å›å¾©', type: 'heal', power: 100 } },
                // ãƒ¡ã‚¿ãƒ«
                { no: 101, name: 'ãƒ¡ã‚¿ãƒ«ã‚¹ãƒ©ã‚¤ãƒ ', hp: 50, atk: 5, def: 500, type: 'ãƒ¡ã‚¿ãƒ«', rarity: 'R', ability: { name: 'é«˜é€Ÿå›é¿', desc: 'ä½•ã‚‚èµ·ã“ã‚‰ãªã„', type: 'none' } },
                { no: 103, name: 'ãƒ€ã‚¤ãƒ¤ãƒ¢ãƒ³ãƒ‰ã‚¹ãƒ©ã‚¤ãƒ ', hp: 800, atk: 150, def: 3000, type: 'ãƒ¡ã‚¿ãƒ«', rarity: 'SSR', ability: { name: 'çµ¶å¯¾é˜²å¾¡', desc: 'å‘³æ–¹å…¨ä½“ã®é˜²å¾¡ã‚’è¶…ã‚¢ãƒƒãƒ—', type: 'buff_def', power: 1.8, turns: 2 } },
                // ã‚¢ãƒ³ãƒ‡ãƒƒãƒ‰
                { no: 180, name: 'ã‚¾ãƒ³ãƒ“ã‚¹ãƒ©ã‚¤ãƒ ', hp: 400, atk: 45, def: 30, type: 'ã‚¢ãƒ³ãƒ‡ãƒƒãƒ‰', rarity: 'R', ability: { name: 'ãƒªãƒ´ã‚¡ã‚¤ãƒ–', desc: 'ä½•ã‚‚èµ·ã“ã‚‰ãªã„', type: 'none' } },
                { no: 183, name: 'ãƒªãƒƒãƒã‚¹ãƒ©ã‚¤ãƒ ', hp: 2800, atk: 320, def: 250, type: 'ã‚¢ãƒ³ãƒ‡ãƒƒãƒ‰', rarity: 'SSR', ability: { name: 'ãƒ‡ãƒƒãƒ‰ãƒªãƒ¼ã‚«ãƒ¼ã‚¹', desc: 'æ•µå˜ä½“ã«é—‡ã®å¤§ãƒ€ãƒ¡ãƒ¼ã‚¸', type: 'damage', power: 2.0 } },
                 // ä¼èª¬
                { no: 585, name: 'è™¹é¾ç¥ã‚¹ãƒ©ã‚¤ãƒ ', hp: 8888, atk: 888, def: 888, type: 'ä¼èª¬', rarity: 'UR', ability: { name: 'ä¸ƒè‰²ã®å¥‡è·¡', desc: 'å‘³æ–¹å…¨ä½“ã®HPã‚’å…¨å›å¾©', type: 'full_heal' } },
                { no: 586, name: 'è™šç„¡ã®ã‚¹ãƒ©ã‚¤ãƒ ', hp: 10000, atk: 1000, def: 1000, type: 'ä¼èª¬', rarity: 'UR', ability: { name: 'å­˜åœ¨æŠ¹æ¶ˆ', desc: 'æ•µå˜ä½“ã«è¶…çµ¶ãƒ€ãƒ¡ãƒ¼ã‚¸', type: 'damage', power: 5.0 } },
                { no: 587, name: 'å‰µé€ ä¸»ã®ã‚¹ãƒ©ã‚¤ãƒ ', hp: 99999, atk: 2500, def: 2500, type: 'ç¥', rarity: 'UR', ability: { name: 'ä¸–ç•Œå‰µé€ ', desc: 'å‘³æ–¹å…¨ä½“ã‚’å…¨å›å¾©ã—ã€æ”»æ’ƒé˜²å¾¡ã‚¢ãƒƒãƒ—', type: 'special_buff_heal' } }
            ];
            
            const existingNos = new Set(slimes.map(s => s.no));
            let currentNo = 1;
            const types = ['ç«', 'æ°´', 'é¢¨', 'åœ°', 'å…‰', 'é—‡', 'è‡ªç„¶', 'é­”æ³•', 'æ©Ÿæ¢°', 'ç‰¹æ®Š'];
            const names1 = ['ãƒ—ãƒ', 'ãƒãƒ¼ãƒãƒ«', 'ãƒã‚¤', 'ã‚®ã‚¬', 'ãƒ†ãƒ©', 'ã‚´ãƒƒãƒ‰'];
            const names2 = ['ãƒŠã‚¤ãƒˆ', 'ãƒ¡ã‚¤ã‚¸', 'ã‚¢ãƒ¼ãƒãƒ£ãƒ¼', 'ã‚·ãƒ¼ã‚«ãƒ¼', 'ãƒãƒ¼ã‚µãƒ¼ã‚«ãƒ¼'];

            while(slimes.length < 587) {
                while(existingNos.has(currentNo)) { currentNo++; }
                const type = types[Math.floor(Math.random() * types.length)];
                const rank = Math.floor(Math.random() * names1.length);
                const job = names2[Math.floor(Math.random() * names2.length)];
                const name = `${names1[rank]}${job}ã‚¹ãƒ©ã‚¤ãƒ `;
                const stat_base = Math.pow(10, rank + 1);
                const hp = Math.floor(stat_base * (Math.random() * 2 + 3));
                const atk = Math.floor(stat_base * (Math.random() * 1 + 0.5));
                const def = Math.floor(stat_base * (Math.random() * 1 + 0.5));
                let rarity = 'N';
                if (rank >= 2) rarity = 'R'; // ãƒã‚¤
                if (rank >= 4) rarity = 'SR'; // ãƒ†ãƒ©
                if (rank >= 5) rarity = 'SSR';// ã‚´ãƒƒãƒ‰
                slimes.push({ no: currentNo, name, hp, atk, def, type, rarity, ability: { name: 'ãƒ©ãƒ³ãƒ€ãƒ ã‚¢ã‚¿ãƒƒã‚¯', desc: 'æ•µã«ãƒ€ãƒ¡ãƒ¼ã‚¸', type: 'damage', power: 1.0 + rank * 0.2 } });
                existingNos.add(currentNo);
            }
            return slimes.sort((a,b) => a.no - b.no);
        }

        function createSlimeHTML(slime, isEnemy = false) {
            const bgColor = slimeTypeColors[slime.type] || '#d1d5db';
            const bodyStyle = slime.type === 'ä¼èª¬' || slime.type === 'ç¥' ? `background: ${bgColor};` : `background-color: ${bgColor};`;
            const enemyClass = isEnemy ? 'transform: scaleX(-1);' : '';
            return `
                <div class="slime-icon" style="${enemyClass}">
                    <div class="slime-body" style="${bodyStyle}">
                        <div class="slime-eyes"><div class="slime-eye"></div><div class="slime-eye"></div></div>
                    </div>
                </div>
            `;
        }

        allSlimes = generateSlimeDatabase();
        
        const gachaSlimes = allSlimes.filter(s => s.type !== 'åŸºæœ¬');

        let player = { slimes: [], party: [], coins: 30, storyProgress: 1 };
        const gameState = { currentScreen: 'loading-screen', battle: null, onlineMatchId: null };

        window.showScreen = (screenId) => {
            document.getElementById(gameState.currentScreen).classList.remove('active');
            document.getElementById(screenId).classList.add('active');
            gameState.currentScreen = screenId;
            if (screenId === 'collection-screen') updateCollectionScreen();
            if (screenId === 'gacha-screen') updateGachaScreen();
            if (screenId === 'story-map-screen') updateStoryMap();
            if (screenId === 'party-formation-screen') updatePartyFormationScreen();
        }

        function saveGame() {
            localStorage.setItem('slimeWarSave', JSON.stringify({
                slimes: player.slimes.map(s => s.no),
                party: player.party.map(s => s.no),
                coins: player.coins,
                storyProgress: player.storyProgress,
            }));
        }

        function loadGame() {
            const saveData = localStorage.getItem('slimeWarSave');
            if (saveData) {
                const loaded = JSON.parse(saveData);
                player.slimes = loaded.slimes.map(no => allSlimes.find(s => s.no === no)).filter(Boolean);
                player.party = loaded.party ? loaded.party.map(no => allSlimes.find(s => s.no === no)).filter(Boolean) : player.slimes.slice(0, 3);
                player.coins = loaded.coins;
                player.storyProgress = loaded.storyProgress;
                return true;
            }
            return false;
        }

        window.onload = async () => {
            if (!loadGame()) {
                showScreen('partner-select-screen');
                setupPartnerSelection();
            } else {
                if(player.party.length === 0 && player.slimes.length > 0) {
                   player.party = player.slimes.slice(0,1);
                }
                showScreen('home-screen');
            }
            await checkFirebaseStatus();
            document.getElementById('loading-screen').classList.remove('active');
        };
        
        function setupPartnerSelection() {
            const optionsContainer = document.getElementById('partner-options');
            const partners = [allSlimes.find(s=>s.no===1), allSlimes.find(s=>s.no===12), allSlimes.find(s=>s.no===20)];
            let selectedPartnerNo = partners[0].no;
            
            optionsContainer.innerHTML = partners.map(slime => `
                <div class="partner-card border-4 border-transparent p-2 rounded-2xl cursor-pointer" data-no="${slime.no}">
                    ${createSlimeHTML(slime)}
                    <p class="font-bold text-center mt-2">${slime.name}</p>
                </div>
            `).join('');
            
            const cards = optionsContainer.querySelectorAll('.partner-card');
            cards[0].classList.replace('border-transparent', 'border-blue-500');

            cards.forEach(card => card.addEventListener('click', () => {
                cards.forEach(c => c.classList.replace('border-blue-500', 'border-transparent'));
                card.classList.replace('border-transparent', 'border-blue-500');
                selectedPartnerNo = parseInt(card.dataset.no);
            }));

            document.getElementById('confirm-partner-btn').onclick = () => {
                const chosenSlime = allSlimes.find(s => s.no === selectedPartnerNo);
                player.slimes.push(chosenSlime);
                player.party = [chosenSlime];
                saveGame();
                showScreen('home-screen');
            };
        }

        function updatePartyFormationScreen() {
            const partyContainer = document.getElementById('current-party-display');
            const ownedContainer = document.getElementById('owned-slimes-list');

            const totalStats = player.party.reduce((acc, s) => {
                acc.hp += s.hp; acc.atk += s.atk; acc.def += s.def; return acc;
            }, {hp: 0, atk: 0, def: 0});

            document.getElementById('party-total-stats').innerHTML = `
                <span class="text-green-600">H:${totalStats.hp}</span>
                <span class="text-red-600">A:${totalStats.atk}</span>
                <span class="text-blue-600">D:${totalStats.def}</span>
            `;

            partyContainer.innerHTML = player.party.map(slime => `
                <div class="text-center p-1 bg-blue-200 rounded-lg cursor-pointer" onclick="removeFromParty(${slime.no})">
                    ${createSlimeHTML(slime)}
                    <p class="text-xs font-bold truncate">${slime.name}</p>
                    <div class="text-[9px] leading-tight">
                        <span class="text-green-600">H:${slime.hp}</span>
                        <span class="text-red-600">A:${slime.atk}</span>
                        <span class="text-blue-600">D:${slime.def}</span>
                    </div>
                </div>
            `).join('');

            const nonPartySlimes = player.slimes.filter(s => !player.party.some(p => p.no === s.no));
            ownedContainer.innerHTML = nonPartySlimes.map(slime => `
                 <div class="text-center p-1 bg-white rounded-lg cursor-pointer" onclick="addToParty(${slime.no})">
                    ${createSlimeHTML(slime)}
                    <p class="text-[10px] font-bold truncate">${slime.name}</p>
                    <div class="text-[9px] leading-tight">
                        <span class="text-green-600">H:${slime.hp}</span>
                        <span class="text-red-600">A:${slime.atk}</span>
                        <span class="text-blue-600">D:${slime.def}</span>
                    </div>
                </div>
            `).join('');
        }

        window.addToParty = (slimeNo) => {
            if (player.party.length < 3) {
                const slimeToAdd = player.slimes.find(s => s.no === slimeNo);
                player.party.push(slimeToAdd);
                saveGame();
                updatePartyFormationScreen();
            } else {
                alert('ãƒ‘ãƒ¼ãƒ†ã‚£ã¯3åŒ¹ã¾ã§ã§ã™ã€‚');
            }
        }

        window.removeFromParty = (slimeNo) => {
            player.party = player.party.filter(s => s.no !== slimeNo);
            saveGame();
            updatePartyFormationScreen();
        }

        function updateCollectionScreen() {
            const grid = document.getElementById('collection-grid');
            grid.innerHTML = allSlimes.map(slime => {
                const owned = player.slimes.some(s => s.no === slime.no);
                const slimeHTML = createSlimeHTML(slime);
                if (owned) {
                    return `
                        <div class="text-center p-1 rounded-lg bg-blue-200 flex flex-col justify-between">
                            <p class="text-[10px] font-bold">${slime.no}:${slime.name}</p>
                            <div class="mx-auto w-16 h-16 flex justify-center items-center">${slimeHTML}</div>
                            <div class="text-[9px] leading-tight mt-1">
                                <span class="text-green-600">H:${slime.hp}</span><br>
                                <span class="text-red-600">A:${slime.atk}</span>
                                <span class="text-blue-600">D:${slime.def}</span>
                            </div>
                        </div>
                    `;
                } else {
                    return `
                        <div class="text-center p-1 rounded-lg bg-gray-200 flex flex-col justify-between">
                            <p class="text-[10px] font-bold text-gray-400">${slime.no}:ï¼Ÿï¼Ÿï¼Ÿ</p>
                            <div class="mx-auto w-16 h-16 flex justify-center items-center opacity-25">${slimeHTML}</div>
                             <div class="text-[9px] leading-tight mt-1 text-gray-400">
                                <span>H:???</span><br>
                                <span>A:???</span>
                                <span>D:???</span>
                            </div>
                        </div>
                    `;
                }
            }).join('');
        }
        
        function updateGachaScreen() {
            document.getElementById('gacha-coin-count').textContent = player.coins;
        }

        function updateStoryMap() {
            const stageList = document.getElementById('stage-list');
            stageList.innerHTML = Array.from({length: 76}, (_, i) => i + 1).map(i => {
                const isCleared = i < player.storyProgress, isCurrent = i === player.storyProgress;
                let stageClass = `bg-gray-300 text-gray-500 ${isCurrent ? 'cursor-pointer' : 'cursor-not-allowed'}`;
                if (isCleared) stageClass = 'bg-yellow-400 text-white';
                if (isCurrent) stageClass = 'bg-blue-500 text-white animate-pulse';
                return `<button onclick="${isCurrent ? `startBattle(${i})` : ''}" class="w-12 h-12 rounded-full flex items-center justify-center font-bold text-lg ${stageClass}">${i}</button>`;
            }).join('');
        }
        
        function performGacha(count) {
            const cost = count === 10 ? 80 : 10;
            if (player.coins < cost) { alert('ã‚³ã‚¤ãƒ³ãŒè¶³ã‚Šã¾ã›ã‚“ï¼'); return; }
            player.coins -= cost;

            const animationScreen = document.getElementById('gacha-animation-screen');
            const chest = animationScreen.querySelector('.gacha-chest');
            const light = animationScreen.querySelector('.gacha-light');
            showScreen('gacha-animation-screen');

            chest.textContent = 'ğŸ';
            chest.classList.add('shaking');
            
            setTimeout(() => {
                chest.classList.remove('shaking');
                chest.textContent = 'âœ¨';
                light.classList.add('glowing');

                setTimeout(() => {
                    let hpLimit = Infinity, atkLimit = Infinity;
                    if (player.storyProgress < 50) {
                        if (player.storyProgress <= 10) { hpLimit = 800; atkLimit = 100; } 
                        else if (player.storyProgress <= 20) { hpLimit = 2000; atkLimit = 300; } 
                        else if (player.storyProgress <= 49) { hpLimit = 5000; atkLimit = 500; }
                    }
                    const availableGachaSlimes = gachaSlimes.filter(s => s.hp <= hpLimit && s.atk <= atkLimit);

                    const rarityPools = { N: [], R: [], SR: [], SSR: [], UR: [] };
                    availableGachaSlimes.forEach(s => {
                        if (rarityPools[s.rarity]) rarityPools[s.rarity].push(s);
                    });

                    let rates = { N: 0.70, R: 0.23, SR: 0.05, SSR: 0.015, UR: 0.005 };
                    const progressBonus = Math.min(0.15, player.storyProgress / 76 * 0.15); 
                    rates.N -= progressBonus;
                    rates.R += progressBonus * 0.7;
                    rates.SR += progressBonus * 0.2;
                    rates.SSR += progressBonus * 0.08;
                    rates.UR += progressBonus * 0.02;

                    const pullSlime = () => {
                        const roll = Math.random();
                        let cumulative = 0;
                        for (const rarity in rates) {
                            cumulative += rates[rarity];
                            if (roll < cumulative) {
                                const pool = rarityPools[rarity];
                                if (pool && pool.length > 0) return pool[Math.floor(Math.random() * pool.length)];
                            }
                        }
                        const fallbackPool = rarityPools['N'] || availableGachaSlimes.filter(s => s.rarity === 'N');
                        return fallbackPool[Math.floor(Math.random() * fallbackPool.length)];
                    };
                    
                    const results = Array.from({length: count}, () => pullSlime());
                    const processedResults = [];

                    results.forEach(pulledSlime => {
                        if (!pulledSlime) return; 
                        const isOwned = player.slimes.some(s => s.no === pulledSlime.no);
                        if (isOwned) {
                            let coinReward = 0;
                            switch(pulledSlime.rarity) {
                                case 'R': coinReward = 5; break;
                                case 'SR': coinReward = 20; break;
                                case 'SSR': coinReward = 50; break;
                                case 'UR': coinReward = 100; break;
                                default: coinReward = 2;
                            }
                            player.coins += coinReward;
                            processedResults.push({ slime: pulledSlime, isNew: false, coinReward });
                        } else {
                            player.slimes.push(pulledSlime);
                            processedResults.push({ slime: pulledSlime, isNew: true, coinReward: 0 });
                        }
                    });
                    
                    saveGame();
                    updateGachaScreen();
                    
                    const resultGrid = document.getElementById('gacha-result-grid');
                    resultGrid.innerHTML = processedResults.map(res => `
                        <div class="text-center relative p-1 rounded-lg ${res.isNew ? 'bg-yellow-200' : 'bg-gray-200'}">
                            ${res.isNew ? '<span class="absolute top-0 right-0 bg-red-500 text-white text-[8px] font-bold px-1 py-0.5 rounded-full z-10">NEW</span>' : ''}
                            ${createSlimeHTML(res.slime)}
                            <p class="text-xs truncate font-bold">${res.slime.name}</p>
                            ${!res.isNew ? `<p class="text-[10px] text-yellow-600 font-bold">+${res.coinReward}ã‚³ã‚¤ãƒ³</p>` : `<p class="text-[10px] text-transparent">.</p>`}
                        </div>
                    `).join('');
                    document.getElementById('gacha-result-modal').style.display = 'flex';

                    chest.textContent = 'ğŸ';
                    light.classList.remove('glowing');
                    showScreen('gacha-screen');
                }, 1500);

            }, 500);
        }
        
        document.getElementById('gacha-single-btn').onclick = () => performGacha(1);
        document.getElementById('gacha-multi-btn').onclick = () => performGacha(10);
        
        // --- Battle Logic ---
        window.startBattle = (stage) => {
            if (player.party.length === 0) { alert("ãƒ‘ãƒ¼ãƒ†ã‚£ã«ã‚¹ãƒ©ã‚¤ãƒ ãŒã„ã¾ã›ã‚“ï¼"); return; }
            document.getElementById('player-name').textContent = `ã‚ãªãŸ`;
            document.getElementById('enemy-name').textContent = `ã¦ã`;

            let enemyCount = 1, enemyPool = [], scalingFactor = 1.0;

            if (stage <= 5) {
                enemyPool = [ allSlimes.find(s=>s.no===1), allSlimes.find(s=>s.no===12), allSlimes.find(s=>s.no===20) ];
                if(stage > 2) { enemyPool.push(allSlimes.find(s => s.no === 2)); }
                enemyCount = 1;
                if (stage >= 2) enemyCount = 2;
                if (stage >= 4) enemyCount = 3;
                scalingFactor = 0.8 + stage * 0.15;
            } else {
                enemyCount = 3;
                const poolLimit = Math.min(allSlimes.length, 10 + (stage - 5) * 4);
                enemyPool = allSlimes.slice(0, poolLimit);
                scalingFactor = 1.0 + (stage - 5) * 0.2;
            }

            const enemyTeam = Array.from({length: enemyCount}, () => {
                let et = { ...enemyPool[Math.floor(Math.random() * enemyPool.length)] };
                const attackMultiplier = (stage <= 5) ? 2.5 : 1.0;
                et.hp = Math.max(10, Math.floor(et.hp * scalingFactor));
                et.atk = Math.max(5, Math.floor(et.atk * scalingFactor * attackMultiplier));
                et.def = Math.max(5, Math.floor(et.def * scalingFactor));
                return et;
            });

            gameState.battle = {
                online: false, stage, playerTeam: JSON.parse(JSON.stringify(player.party)), enemyTeam,
                playerTotalStats: calculateTeamStats(player.party),
                enemyTotalStats: calculateTeamStats(enemyTeam),
                turn: 'mash', phase: 'attack',
                playerLegendPower: 0, legendPowerMax: 100
            };
            gameState.battle.playerTotalStats.currentHp = gameState.battle.playerTotalStats.hp;
            gameState.battle.enemyTotalStats.currentHp = gameState.battle.enemyTotalStats.hp;
            setupBattleUI();
            showScreen('battle-screen');
            startMashBattle();
        };

        function calculateTeamStats(team) {
            return team.reduce((acc, slime) => {
                acc.hp += slime.hp; acc.atk += slime.atk; acc.def += slime.def; return acc;
            }, { hp: 0, atk: 0, def: 0 });
        }
        
        function setupBattleUI() {
            const { playerTeam, enemyTeam } = gameState.battle;
            document.getElementById('player-area').querySelector('.flex').innerHTML = playerTeam.map(s => createSlimeHTML(s)).join('');
            document.getElementById('enemy-area').querySelector('.flex').innerHTML = enemyTeam.map(s => createSlimeHTML(s, true)).join('');
            updateHpBars();
            updateLegendPowerBar();
        }

        function updateHpBars() {
            const { playerTotalStats, enemyTotalStats } = gameState.battle;
            const playerHpPercent = Math.max(0, (playerTotalStats.currentHp / playerTotalStats.hp) * 100);
            const enemyHpPercent = Math.max(0, (enemyTotalStats.currentHp / enemyTotalStats.hp) * 100);
            document.getElementById('player-hp-bar').style.width = `${playerHpPercent}%`;
            document.getElementById('player-hp-text').textContent = `HP: ${playerTotalStats.currentHp} / ${playerTotalStats.hp}`;
            document.getElementById('enemy-hp-bar').style.width = `${enemyHpPercent}%`;
            document.getElementById('enemy-hp-text').textContent = `HP: ${enemyTotalStats.currentHp} / ${enemyTotalStats.hp}`;
        }
                
        function setBattleMessage(msg) { document.getElementById('battle-message').textContent = msg; }

        function updateLegendPowerBar() {
            const battle = gameState.battle; if (!battle) return;
            const percent = Math.min(100, (battle.playerLegendPower / battle.legendPowerMax) * 100);
            const bar = document.getElementById('legend-power-bar');
            if (bar) bar.style.width = `${percent}%`;
            const text = document.getElementById('legend-power-text');
            if(text) text.textContent = `ãƒ¬ã‚¸ã‚§ãƒ³ãƒ‰ãƒ‘ãƒ¯ãƒ¼: ${battle.playerLegendPower} / ${battle.legendPowerMax}`;

            const specialBtn = document.getElementById('special-btn');
            if (battle.playerLegendPower >= battle.legendPowerMax) {
                specialBtn.textContent = 'ã¨ãã—ã‚…ã®ã†ã‚Šã‚‡ãï¼';
                specialBtn.classList.remove('btn-disabled');
                specialBtn.classList.add('animate-pulse', 'bg-yellow-400', 'border-yellow-600');
            } else {
                specialBtn.textContent = 'ã¨ãã—ã‚…ã®ã†ã‚Šã‚‡ã';
                specialBtn.classList.add('btn-disabled');
                specialBtn.classList.remove('animate-pulse', 'bg-yellow-400', 'border-yellow-600');
            }
        }

        function chargeLegendPower(amount) {
            const battle = gameState.battle; if (!battle) return;
            battle.playerLegendPower = Math.min(battle.legendPowerMax, battle.playerLegendPower + amount);
            updateLegendPowerBar();
        }

        function battleTurn() { // Offline battle turn logic
            const battle = gameState.battle;
            if (battle.playerTotalStats.currentHp <= 0 || battle.enemyTotalStats.currentHp <= 0) { endBattle(); return; }
            
            if (battle.turn === 'player') {
                setBattleMessage('ã‚ãªãŸã®ã‚¿ãƒ¼ãƒ³ï¼');
                document.getElementById('battle-actions-area').style.display = 'flex';
                document.getElementById('slot-machine-area').style.display = 'none';
                document.getElementById('special-select-area').style.display = 'none';
            } else { // CPU turn
                setBattleMessage('ç›¸æ‰‹ã®ã‚¿ãƒ¼ãƒ³ï¼');
                document.getElementById('battle-actions-area').style.display = 'none';
                if (Math.random() < 0.4) {
                    const cpuAttacker = battle.enemyTeam[Math.floor(Math.random() * battle.enemyTeam.length)];
                    setTimeout(() => {
                        setBattleMessage(`ç›¸æ‰‹ã®${cpuAttacker.name}ãŒ${cpuAttacker.ability.name}ã‚’ä½¿ã£ãŸï¼`);
                        applyAbility(cpuAttacker.ability, 'enemy');
                        setTimeout(() => { battle.turn = 'player'; battleTurn(); }, 2000);
                    }, 1500);
                } else {
                    battle.enemyMatchCount = [1, 1, 2, 3][Math.floor(Math.random() * 4)];
                    setTimeout(() => {
                        battle.phase = 'defense'; 
                        setBattleMessage('ç›¸æ‰‹ãŒæ”»æ’ƒã—ã¦ãã‚‹ï¼é˜²å¾¡ã—ã‚ï¼');
                        document.getElementById('slot-machine-area').style.display = 'flex';
                        startSlotMachine();
                    }, 1500);
                }
            }
        }
        
        document.getElementById('attack-btn').onclick = () => {
            gameState.battle.phase = 'attack';
            document.getElementById('battle-actions-area').style.display = 'none';
            document.getElementById('slot-machine-area').style.display = 'flex';
            startSlotMachine();
        };

        document.getElementById('special-btn').onclick = () => {
            const battle = gameState.battle;
            if (battle.playerLegendPower >= battle.legendPowerMax) {
                document.getElementById('battle-actions-area').style.display = 'none';
                const selectArea = document.getElementById('special-select-area');
                selectArea.innerHTML = gameState.battle.playerTeam.map((slime, i) => 
                    `<button onclick="useSpecialAbility(${i})" class="btn btn-special w-full text-sm">${slime.name}ã®ã€Œ${slime.ability.name}ã€</button>`
                ).join('');
                selectArea.style.display = 'flex';
            } else {
                setBattleMessage('ãƒ¬ã‚¸ã‚§ãƒ³ãƒ‰ãƒ‘ãƒ¯ãƒ¼ãŒè¶³ã‚Šãªã„ï¼');
            }
        };

        window.useSpecialAbility = (partyIndex) => {
            const slime = gameState.battle.playerTeam[partyIndex];
            setBattleMessage(`${slime.name}ã®ã€Œ${slime.ability.name}ã€ï¼`);
            applyAbility(slime.ability, 'player');
            gameState.battle.playerLegendPower = 0;
            updateLegendPowerBar();
            document.getElementById('special-select-area').style.display = 'none';
            
            if(gameState.battle.online) {
                const enemyUid = gameState.battle.isPlayer1 ? gameState.battle.enemyTeam.uid : gameState.battle.playerTeam.uid;
                // update firestore
            } else {
                 setTimeout(() => {
                    gameState.battle.turn = 'enemy';
                    battleTurn();
                }, 2000);
            }
        };

        function applyAbility(ability, caster) {
            const battle = gameState.battle;
            const [casterStats, targetStats] = caster === 'player' ? [battle.playerTotalStats, battle.enemyTotalStats] : [battle.enemyTotalStats, battle.playerTotalStats];
            let message = '';
            switch (ability.type) {
                case 'damage':
                    const damage = Math.max(0, Math.floor(casterStats.atk * ability.power - targetStats.def / 3));
                    targetStats.currentHp -= damage;
                    message = `${damage}ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼`; break;
                case 'heal':
                    casterStats.currentHp = Math.min(casterStats.hp, casterStats.currentHp + ability.power);
                    message = `HPãŒ${ability.power}å›å¾©ã—ãŸï¼`; break;
                case 'full_heal':
                     casterStats.currentHp = casterStats.hp;
                     message = 'HPãŒå…¨å›å¾©ã—ãŸï¼'; break;
                case 'buff_atk': case 'buff_def':
                     message = `${caster==='player'?'å‘³æ–¹':'æ•µ'}ã®${ability.type.includes('atk')?'æ”»æ’ƒ':'é˜²å¾¡'}ãŒä¸ŠãŒã£ãŸï¼`; break;
                case 'special_buff_heal':
                    casterStats.currentHp = casterStats.hp;
                    message = 'HPãŒå…¨å›å¾©ã—ã€èƒ½åŠ›ãŒä¸ŠãŒã£ãŸï¼'; break;
            }
            setBattleMessage(message);
            updateHpBars();
        }

        let reels = [], reelIntervals = [], stoppedReels = 0;
        function startSlotMachine() {
            document.querySelectorAll('.slot-item.matched').forEach(el => el.classList.remove('matched'));
            reels = [document.getElementById('reel1'), document.getElementById('reel2'), document.getElementById('reel3')];
            reelIntervals = []; stoppedReels = 0;
            
            reels.forEach((reel, i) => {
                let content = '';
                for(let j=0; j<20; j++) content += `<div class="slot-item">${slotItems[Math.floor(Math.random() * slotItems.length)]}</div>`;
                reel.innerHTML = content;
                reel.style.top = '0px';
                reel.style.transition = 'top 0.1s linear';
                reelIntervals[i] = setInterval(() => {
                    let top = parseInt(reel.style.top) - 20;
                    if (top < - (reel.scrollHeight - reel.parentElement.clientHeight)) top += reel.scrollHeight / 2;
                    reel.style.top = `${top}px`;
                }, 30);
            });
            document.getElementById('stop-btn').disabled = false;
        }

        document.getElementById('stop-btn').onclick = () => {
            if (stoppedReels < 3) {
                clearInterval(reelIntervals[stoppedReels]);
                const reel = reels[stoppedReels], reelContainer = reel.parentElement, items = reel.querySelectorAll('.slot-item');
                let closest = { el: null, dist: Infinity };
                items.forEach(item => {
                    const itemRect = item.getBoundingClientRect(), containerRect = reelContainer.getBoundingClientRect();
                    const dist = Math.abs((itemRect.top + itemRect.height / 2) - (containerRect.top + containerRect.height / 2));
                    if (dist < closest.dist) { closest.dist = dist; closest.el = item; }
                });
                const finalTop = -closest.el.offsetTop + (reelContainer.clientHeight - closest.el.clientHeight) / 2;
                reel.style.transition = 'top 0.5s cubic-bezier(0.25, 1, 0.5, 1)';
                reel.style.top = `${finalTop}px`;
                stoppedReels++;
                if (stoppedReels === 3) {
                    document.getElementById('stop-btn').disabled = true;
                    setTimeout(calculateTurnResult, 1000);
                }
            }
        };

        function getSlotResultElements() {
            return reels.map(reel => {
                const items = reel.querySelectorAll('.slot-item');
                let closest = { el: null, dist: Infinity };
                items.forEach(item => {
                    const itemRect = item.getBoundingClientRect(), reelRect = reel.parentElement.getBoundingClientRect();
                    const dist = Math.abs((itemRect.top + itemRect.height / 2) - (reelRect.top + reelRect.height / 2));
                    if (dist < closest.dist) { closest.dist = dist; closest.el = item; }
                });
                return closest.el;
            });
        }
        
        async function calculateTurnResult() {
            const results = getSlotResultElements().map(el => el.textContent.trim());
            const counts = results.reduce((acc, val) => { acc[val] = (acc[val] || 0) + 1; return acc; }, {});
            const matchCount = results.length > 0 ? Math.max(...Object.values(counts)) : 1;

            if (matchCount > 1) {
                let matchedValue = null;
                for (const [value, count] of Object.entries(counts)) { if (count >= matchCount) { matchedValue = value; break; } }
                if (matchedValue) {
                    getSlotResultElements().forEach(el => {
                        if (el.textContent.trim() === matchedValue) el.classList.add('matched');
                    });
                }
            }
            const battle = gameState.battle;
            if (battle.online) {
                const myKey = battle.isPlayer1 ? 'player1' : 'player2';
                const enemyKey = battle.isPlayer1 ? 'player2' : 'player1';
                const enemyUid = battle.isPlayer1 ? matchData.player2_uid : matchData.player1_uid;

                let updateData = {};
                if (battle.phase === 'attack') {
                    let multiplier = 1;
                    if (matchCount === 2) multiplier = 1.8;
                    if (matchCount === 3) multiplier = 2.5;
                    const damage = Math.max(0, Math.floor(battle.playerTotalStats.atk * multiplier - battle.enemyTotalStats.def / 3));
                    battle.enemyTotalStats.currentHp -= damage;
                    const powerGained = 20 + Math.floor(Math.random() * 31);
                    battle.playerLegendPower += powerGained;

                    updateData.turn = enemyUid;
                    updateData.phase = 'defense';
                    updateData[enemyKey + '_currentHp'] = battle.enemyTotalStats.currentHp;
                    updateData[myKey + '_legendPower'] = battle.playerLegendPower;
                    updateData.lastAction = { type: 'slot_attack', matchCount: matchCount, damage: damage };
                } else { // 'defense'
                     let reduction = 1;
                     if (matchCount === 2) reduction = 0.9;
                     if (matchCount === 3) reduction = 0.6;
                     const enemyDamage = Math.max(0, Math.floor( (battle.lastAction.damage) * reduction));
                     battle.playerTotalStats.currentHp -= enemyDamage;
                     
                     updateData.turn = enemyUid;
                     updateData.phase = 'attack';
                     updateData[myKey + '_currentHp'] = battle.playerTotalStats.currentHp;
                     updateData.lastAction = { type: 'slot_defense', matchCount: matchCount, finalDamage: enemyDamage };
                }
                if (battle.playerTotalStats.currentHp <= 0) updateData.winner = enemyUid;
                if (battle.enemyTotalStats.currentHp <= 0) updateData.winner = auth.currentUser.uid;
                
                await updateMatchInFirestore(updateData);
            } else { // Offline
                if (battle.phase === 'attack') { 
                    let multiplier = 1;
                    if (matchCount === 2) multiplier = 1.8;
                    if (matchCount === 3) multiplier = 2.5;
                    const damage = Math.max(0, Math.floor(battle.playerTotalStats.atk * multiplier - battle.enemyTotalStats.def / 3));
                    setBattleMessage(`${matchCount}å€‹æƒã£ãŸï¼ ${damage} ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼`);
                    battle.enemyTotalStats.currentHp -= damage;
                    const powerGained = 20 + Math.floor(Math.random() * 31);
                    chargeLegendPower(powerGained);
                    battle.turn = 'enemy';
                } else { // 'defense'
                    let reduction = 1;
                    if (matchCount === 2) reduction = 0.9;
                    if (matchCount === 3) reduction = 0.6;
                    let enemyMultiplier = 1;
                    if (battle.enemyMatchCount === 2) enemyMultiplier = 1.8;
                    if (battle.enemyMatchCount === 3) enemyMultiplier = 2.5;
                    const enemyBaseAttack = battle.enemyTotalStats.atk * enemyMultiplier;
                    const enemyDamage = Math.max(0, Math.floor((enemyBaseAttack - battle.playerTotalStats.def / 3) * reduction));
                    setBattleMessage(`${matchCount}å€‹ã§é˜²å¾¡ï¼ ${enemyDamage} ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ãŸï¼`);
                    battle.playerTotalStats.currentHp -= enemyDamage;
                    battle.turn = 'player';
                }
                updateHpBars();
                setTimeout(battleTurn, 2000);
            }
        }

        function endBattle() {
            const battle = gameState.battle;
            if(!battle) return;
            const modal = document.getElementById('battle-result-modal');
            const title = document.getElementById('result-title');
            const rewards = document.getElementById('result-rewards');

            if (battle.online) {
                const iAmWinner = battle.winner === auth.currentUser.uid;
                title.textContent = iAmWinner ? "å‹åˆ©ï¼" : "æ•—åŒ—...";
                title.style.color = iAmWinner ? '#22c55e' : '#ef4444';
                rewards.innerHTML = "ã‚ªãƒ³ãƒ©ã‚¤ãƒ³å¯¾æˆ¦çµ‚äº†ï¼";
                cancelMatching(); // Clean up online match data
            }
            else if (battle.playerTotalStats.currentHp > 0) {
                title.textContent = "å‹åˆ©ï¼";
                title.style.color = '#22c55e';
                const coinsWon = 10 + battle.stage * 2;
                let rewardText = `${coinsWon} ã‚³ã‚¤ãƒ³ç²å¾—ï¼`;
                player.coins += coinsWon;
                if (battle.stage === player.storyProgress) player.storyProgress++;
                if (battle.stage % 3 === 0) {
                    const newSlime = allSlimes[Math.floor(Math.random() * allSlimes.length)];
                    if (!player.slimes.some(s => s.no === newSlime.no)) {
                       player.slimes.push(newSlime);
                       rewardText += `<br>${newSlime.name}ãŒä»²é–“ã«ãªã£ãŸï¼`;
                    }
                }
                rewards.innerHTML = rewardText;
            } else {
                title.textContent = "æ•—åŒ—...";
                title.style.color = '#ef4444';
                rewards.innerHTML = "å†æŒ‘æˆ¦ã—ã‚ˆã†ï¼";
            }
            saveGame();
            modal.style.display = 'flex';
            gameState.battle = null; // Clear battle state
        }
        
        document.getElementById('result-close-btn').onclick = () => {
            const wasOnline = gameState.battle && gameState.battle.online;
            document.getElementById('battle-result-modal').style.display = 'none';
            showScreen(wasOnline ? 'online-lobby-screen' : 'story-map-screen');
            if (wasOnline) cancelMatching();
        };

        function startMashBattle() {
            const modal = document.getElementById('mash-battle-modal');
            modal.style.display = 'flex';
            let timeLeft = 3, mashCount = 0, ended = false;
            const timerEl = document.getElementById('mash-timer');
            timerEl.textContent = timeLeft;

            const endMash = (result) => {
                if(ended) return;
                ended = true;
                clearInterval(countdown);
                const isWinner = result >= (Math.random() * 15 + 5);
                
                if (gameState.battle.online) {
                    const winnerUid = isWinner ? auth.currentUser.uid : 'opponent'; //ä»®
                    // å…ˆè¡Œå¾Œæ”»ã®çµæœã‚’Firestoreã«æ›¸ãè¾¼ã‚€ (Player1ãŒæ›¸ãè¾¼ã‚€)
                    if(gameState.battle.isPlayer1){
                       const p2uid = gameState.battle.enemyTeam.uid; // ä»®
                       updateMatchInFirestore({ turn: isWinner ? auth.currentUser.uid : p2uid, phase: 'attack' });
                    }
                } else {
                    gameState.battle.turn = isWinner ? 'player' : 'enemy';
                    setBattleMessage(isWinner ? "ã‚ãªãŸã®å…ˆè¡Œï¼" : "ç›¸æ‰‹ã®å…ˆè¡Œï¼");
                    setTimeout(battleTurn, 1000);
                }
                modal.style.display = 'none';
            };

            const countdown = setInterval(() => {
                timeLeft--;
                timerEl.textContent = timeLeft;
                if (timeLeft <= 0) {
                    endMash(mashCount);
                }
            }, 1000);
            document.getElementById('mash-btn').onclick = () => { if(timeLeft > 0) mashCount++; };
        }
    </script>
</body>
</html>

