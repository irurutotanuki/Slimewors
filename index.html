<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>スライム戦争</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Mochiy+Pop+One&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Mochiy+Pop+One', sans-serif;
            background-color: #f0f9ff;
            color: #1e3a8a;
            user-select: none;
        }
        .screen {
            display: none;
            width: 100%;
            height: 100vh;
            overflow: hidden;
            position: fixed;
            top: 0;
            left: 0;
        }
        .screen.active {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        .btn {
            background-color: #3b82f6;
            color: white;
            padding: 1rem 2rem;
            border-radius: 9999px;
            font-size: 1.25rem;
            font-weight: bold;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
            transition: all 0.2s ease-in-out;
            border-bottom: 4px solid #1d4ed8;
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.1);
        }
        .btn:active {
            transform: translateY(2px);
            box-shadow: none;
            border-bottom-width: 2px;
        }
        .btn-secondary {
            background-color: #fbbf24;
            border-bottom-color: #d97706;
        }
        .btn-special {
            background-color: #ec4899;
            border-bottom-color: #be185d;
        }
        .btn-disabled {
            background-color: #d1d5db;
            color: #4b5563;
            border-bottom-color: #6b7280;
            cursor: not-allowed;
            opacity: 0.7;
        }
        .card {
            background: white;
            border-radius: 1.5rem;
            padding: 2rem;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            border: 4px solid #93c5fd;
        }
        /* 新しいスライムのスタイル */
        .slime-icon {
            width: 80px;
            height: 80px;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            flex-shrink: 0;
        }
        .slime-body {
            width: 70px;
            height: 60px;
            border-radius: 50% / 60% 60% 40% 40%;
            position: relative;
            border: 3px solid rgba(0,0,0,0.2);
        }
        .slime-eyes {
            position: absolute;
            bottom: 25px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
        }
        .slime-eye {
            width: 6px;
            height: 8px;
            background-color: #2c3e50;
            border-radius: 50%;
        }
        .slot {
            width: 80px;
            height: 100px;
            background: #bfdbfe;
            border: 4px solid #60a5fa;
            border-radius: 1rem;
            overflow: hidden;
            position: relative;
        }
        .slot-reel {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: top 0.1s linear;
        }
        .slot-item {
            font-size: 3rem;
            height: 100px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .hp-bar-container {
            width: 100%;
            height: 20px;
            background-color: #e0e7ff;
            border-radius: 9999px;
            border: 2px solid #93c5fd;
            overflow: hidden;
        }
        .hp-bar {
            height: 100%;
            background: linear-gradient(to right, #4ade80, #22c55e);
            border-radius: 9999px;
            transition: width 0.5s ease-out;
        }
        /* Gacha Animation */
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
            20%, 40%, 60%, 80% { transform: translateX(5px); }
        }
        @keyframes glow {
            0% { transform: scale(0); opacity: 0.5; }
            50% { opacity: 1; }
            100% { transform: scale(3); opacity: 0; }
        }
        .gacha-chest {
            font-size: 150px;
            cursor: pointer;
        }
        .shaking {
            animation: shake 0.5s linear;
        }
        .gacha-light {
            position: absolute;
            width: 100px;
            height: 100px;
            background: radial-gradient(circle, rgba(255,255,0,1) 0%, rgba(255,255,255,0) 70%);
            border-radius: 50%;
            display: none;
        }
        .glowing {
            display: block;
            animation: glow 1.5s ease-out forwards;
        }
        .slot-item.matched {
            transform: scale(1.2);
            background-color: rgba(251, 191, 36, 0.7); /* amber-400 with opacity */
            border-radius: 10px;
            transition: transform 0.3s ease-out, background-color 0.3s ease-out;
        }
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        .plus-value {
            position: absolute;
            top: 0;
            right: 0;
            background-color: #f59e0b;
            color: white;
            font-size: 10px;
            font-weight: bold;
            padding: 1px 4px;
            border-radius: 9999px;
            line-height: 1;
        }
    </style>
</head>
<body class="bg-blue-50">

    <!-- ゲーム全体のコンテナ -->
    <div id="game-container" class="w-full h-screen max-w-lg mx-auto bg-blue-100 shadow-2xl relative">

        <!-- ローディング画面 -->
        <div id="loading-screen" class="screen active p-8">
            <h1 class="text-5xl font-bold text-blue-800 mb-4">スライム戦争</h1>
            <p class="text-xl text-blue-600">Now Loading...</p>
        </div>

        <!-- パートナースライム選択画面 -->
        <div id="partner-select-screen" class="screen p-4 bg-blue-100">
            <div class="card w-full max-w-md text-center">
                <h2 class="text-3xl font-bold mb-4">最初の相棒を選ぼう！</h2>
                <div id="partner-options" class="grid grid-cols-3 gap-4 my-6">
                    <!-- JSで選択肢を生成 -->
                </div>
                <button id="confirm-partner-btn" class="btn btn-secondary w-full">この子に決める！</button>
            </div>
        </div>

        <!-- ホーム画面 -->
        <div id="home-screen" class="screen p-8 space-y-6">
            <h1 class="text-5xl font-bold text-blue-800">スライム戦争</h1>
            <div class="flex flex-col space-y-5 w-full max-w-xs">
                <button onclick="showScreen('play-mode-screen')" class="btn">バトル</button>
                <button onclick="showScreen('party-formation-screen')" class="btn">パーティ編成</button>
                <button onclick="showScreen('synthesis-screen')" class="btn">合成</button>
                <button onclick="showScreen('collection-screen')" class="btn">図鑑を見る</button>
                <button onclick="showScreen('gacha-screen')" class="btn">ガチャる</button>
                <button onclick="showScreen('how-to-play-screen')" class="btn">遊び方</button>
            </div>
            <div class="absolute bottom-8">
                <button onclick="document.getElementById('reset-confirm-modal').style.display='flex'" class="btn bg-red-500 border-red-700 text-sm px-4 py-2">ゲームをリセット</button>
            </div>
        </div>

        <!-- パーティ編成画面 -->
        <div id="party-formation-screen" class="screen p-4">
            <div class="w-full max-w-md h-[90vh] flex flex-col">
                <div class="card flex-grow overflow-hidden flex flex-col">
                    <h2 class="text-2xl font-bold text-center mb-4">パーティ編成</h2>
                    <p class="text-center text-sm mb-2">下のスライムをタップしてパーティを入れ替えよう！</p>
                    <div class="bg-blue-100 p-2 rounded-lg mb-4">
                        <div class="flex justify-between items-center mb-2 px-2">
                             <h3 class="font-bold text-center">現在のパーティ</h3>
                             <p id="party-total-stats" class="text-sm font-bold"></p>
                        </div>
                        <div id="current-party-display" class="grid grid-cols-3 gap-2 min-h-[120px]">
                            <!-- JSで生成 -->
                        </div>
                    </div>
                    <div class="flex-grow overflow-y-auto bg-blue-50 p-2 rounded-lg">
                         <h3 class="font-bold text-center mb-2">手持ちのスライム</h3>
                        <div id="owned-slimes-list" class="grid grid-cols-4 gap-2">
                            <!-- JSで生成 -->
                        </div>
                    </div>
                </div>
                <div class="text-center mt-4">
                     <button onclick="showScreen('home-screen')" class="btn btn-secondary">戻る</button>
                </div>
            </div>
        </div>
        
        <!-- 合成画面 -->
        <div id="synthesis-screen" class="screen p-4">
            <div class="w-full max-w-md h-[90vh] flex flex-col">
                <div class="card flex-grow overflow-hidden flex flex-col">
                    <h2 class="text-2xl font-bold text-center mb-4">スライム合成</h2>
                    <div class="flex justify-around items-center mb-4">
                        <div id="synthesis-base" class="w-32 h-40 border-4 border-dashed border-blue-300 rounded-lg flex flex-col justify-center items-center text-center p-2">
                            <p class="text-sm">ベース</p>
                        </div>
                        <p class="text-2xl font-bold">+</p>
                        <div id="synthesis-material" class="w-32 h-40 border-4 border-dashed border-gray-400 rounded-lg flex flex-col justify-center items-center text-center p-2">
                            <p class="text-sm">素材</p>
                        </div>
                    </div>
                    <div id="synthesis-result-preview" class="text-center mb-4 h-16"></div>
                    <button id="execute-synthesis-btn" class="btn btn-special w-full btn-disabled">合成する</button>

                    <div class="flex-grow overflow-y-auto bg-blue-50 p-2 rounded-lg mt-4">
                         <h3 class="font-bold text-center mb-2">手持ちのスライムを選ぶ</h3>
                        <div id="synthesis-slimes-list" class="grid grid-cols-4 gap-2">
                            <!-- JSで生成 -->
                        </div>
                    </div>
                </div>
                <div class="text-center mt-4">
                     <button onclick="showScreen('home-screen')" class="btn btn-secondary">戻る</button>
                </div>
            </div>
        </div>

        <!-- プレイモード選択画面 -->
        <div id="play-mode-screen" class="screen p-8 space-y-6">
            <h2 class="text-4xl font-bold">プレイモード</h2>
            <div class="flex flex-col space-y-5 w-full max-w-xs">
                <button onclick="showScreen('story-map-screen')" class="btn">ストーリーモード</button>
                <button id="online-mode-btn" class="btn">オンラインモード</button>
                <p id="online-status-text" class="text-center text-sm mt-2"></p>
            </div>
            <button onclick="showScreen('home-screen')" class="btn btn-secondary mt-8">戻る</button>
        </div>

        <!-- オンラインロビー画面 -->
        <div id="online-lobby-screen" class="screen p-8 space-y-6">
            <h2 class="text-4xl font-bold">オンライン対戦</h2>
            <div id="matching-status" class="card w-full max-w-md text-center">
                 <p id="lobby-message" class="text-xl mb-6">対戦相手を探します</p>
                 <button id="start-matching-btn" class="btn" onclick="startMatching()">マッチング開始</button>
                 <div id="matching-loader" class="hidden mx-auto loader"></div>
                 <p id="your-id-text" class="text-xs mt-4 break-all"></p>
            </div>
             <button onclick="cancelMatching(); showScreen('play-mode-screen');" class="btn btn-secondary mt-8">戻る</button>
        </div>

        <!-- ストーリーマップ画面 -->
        <div id="story-map-screen" class="screen p-4">
            <h2 class="text-3xl font-bold text-center my-4">ストーリー</h2>
            <div id="stage-list" class="grid grid-cols-5 gap-4 overflow-y-auto h-[70vh] p-4 bg-white/50 rounded-2xl">
                <!-- ステージはJSで生成 -->
            </div>
            <div class="text-center mt-4">
                <button onclick="showScreen('play-mode-screen')" class="btn btn-secondary">戻る</button>
            </div>
        </div>
        
        <!-- バトル画面 -->
        <div id="battle-screen" class="screen p-4 justify-between bg-green-200">
            <div id="enemy-area" class="w-full text-center">
                 <p id="enemy-name" class="text-sm font-bold truncate"></p>
                <div class="flex justify-center space-x-2"></div>
                <div class="w-full max-w-xs mx-auto mt-2">
                    <div class="hp-bar-container"><div id="enemy-hp-bar" class="hp-bar"></div></div>
                    <p id="enemy-hp-text" class="text-sm font-bold"></p>
                </div>
            </div>

            <div id="battle-message" class="text-center font-bold text-2xl h-16 flex items-center justify-center p-2 bg-white/50 rounded-lg"></div>

            <div id="player-area" class="w-full text-center">
                 <p id="player-name" class="text-sm font-bold truncate"></p>
                 <div class="w-full max-w-xs mx-auto mb-2">
                    <div class="hp-bar-container"><div id="player-hp-bar" class="hp-bar"></div></div>
                    <p id="player-hp-text" class="text-sm font-bold"></p>
                </div>
                <!-- レジェンドパワーゲージを追加 -->
                <div id="legend-power-container" class="w-full max-w-xs mx-auto mt-1">
                    <div class="hp-bar-container border-yellow-400">
                        <div id="legend-power-bar" class="hp-bar bg-gradient-to-r from-purple-400 via-pink-500 to-red-500" style="width: 0%;"></div>
                    </div>
                    <p id="legend-power-text" class="text-sm font-bold text-pink-600 text-center">レジェンドパワー: 0 / 100</p>
                </div>
                <div class="flex justify-center space-x-2 mt-2"></div>
            </div>

            <div id="battle-controls" class="w-full flex flex-col items-center">
                <!-- スロットマシン -->
                <div id="slot-machine-area" class="w-full flex-col items-center p-4 bg-white/70 rounded-2xl hidden">
                    <div class="flex space-x-4">
                        <div class="slot"><div class="slot-reel" id="reel1"></div></div>
                        <div class="slot"><div class="slot-reel" id="reel2"></div></div>
                        <div class="slot"><div class="slot-reel" id="reel3"></div></div>
                    </div>
                    <button id="stop-btn" class="btn mt-4">ストップ！</button>
                </div>
                <!-- アクション選択 -->
                <div id="battle-actions-area" class="w-full flex justify-center space-x-4 p-4">
                    <button id="attack-btn" class="btn">スロット攻撃</button>
                    <button id="special-btn" class="btn btn-special">とくしゅのうりょく</button>
                </div>
                <!-- 特殊能力選択 -->
                <div id="special-select-area" class="w-full flex flex-col items-center p-2 bg-white/70 rounded-2xl hidden space-y-2">
                    <!-- JSで生成 -->
                </div>
            </div>

            <div id="mash-battle-modal" class="absolute inset-0 bg-black/50 hidden items-center justify-center">
                <div class="card text-center">
                    <h3 class="text-3xl font-bold">連打勝負！</h3>
                    <p class="my-4">ボタンを連打して先行を決めろ！</p>
                    <div id="mash-timer" class="text-5xl font-bold my-4">3</div>
                    <button id="mash-btn" class="btn w-40 h-40 rounded-full text-3xl">連打！</button>
                </div>
            </div>
            
            <div id="battle-result-modal" class="absolute inset-0 bg-black/50 hidden items-center justify-center">
                <div class="card text-center">
                    <h3 id="result-title" class="text-5xl font-bold"></h3>
                    <p id="result-rewards" class="my-6 text-xl"></p>
                    <button id="result-close-btn" class="btn btn-secondary">OK</button>
                </div>
            </div>
        </div>

        <!-- 図鑑画面 -->
        <div id="collection-screen" class="screen p-4">
            <h2 class="text-3xl font-bold text-center my-4">スライム図鑑</h2>
            <div id="collection-grid" class="grid grid-cols-4 gap-2 overflow-y-auto h-[70vh] p-2 bg-white/50 rounded-2xl"></div>
            <div class="text-center mt-4">
                <button onclick="showScreen('home-screen')" class="btn btn-secondary">戻る</button>
            </div>
        </div>

        <!-- ガチャ画面 -->
        <div id="gacha-screen" class="screen flex-col p-8 space-y-6">
             <h2 class="text-4xl font-bold">ガチャ</h2>
             <div class="card w-full max-w-md text-center">
                 <p class="text-xl">コイン: <span id="gacha-coin-count">0</span></p>
                 <div class="my-6 space-y-4">
                     <button id="gacha-single-btn" class="btn w-full">1回ガチャる (10コイン)</button>
                     <button id="gacha-multi-btn" class="btn w-full">10回ガチャる (80コイン)</button>
                 </div>
             </div>
             <button onclick="showScreen('home-screen')" class="btn btn-secondary mt-8">戻る</button>
        </div>

        <!-- ガチャアニメーション画面 -->
        <div id="gacha-animation-screen" class="screen">
            <div class="relative flex justify-center items-center">
                <div class="gacha-chest">🎁</div>
                <div class="gacha-light"></div>
            </div>
        </div>

         <!-- ガチャ結果モーダル -->
        <div id="gacha-result-modal" class="absolute inset-0 bg-black/50 hidden items-center justify-center p-4">
            <div class="card w-full max-w-lg text-center">
                <h3 class="text-3xl font-bold mb-4">ガチャ結果</h3>
                <div id="gacha-result-grid" class="grid grid-cols-3 sm:grid-cols-5 gap-2 my-4"></div>
                <button onclick="document.getElementById('gacha-result-modal').style.display='none'" class="btn btn-secondary">閉じる</button>
            </div>
        </div>

        <!-- 遊び方画面 -->
        <div id="how-to-play-screen" class="screen p-4">
             <div class="card w-full max-w-md h-[80vh] overflow-y-auto">
                 <h2 class="text-3xl font-bold text-center mb-4">遊び方</h2>
                 <div class="space-y-4 text-blue-900">
                    <p><strong>1. 合成:</strong> 同じ種類のスライムを合成して強化できる！ベースと素材を選んでコインを消費すると、ベーススライムのステータスが少しアップするぞ。</p>
                    <p><strong>2. バトル:</strong> バトルは「スロット攻撃」と「とくしゅのうりょく」を使い分けて戦うぞ！</p>
                    <p><strong>3. 先行後攻:</strong> バトル開始時の連打勝負で先行・後攻が決まる！</p>
                    <p><strong>4. スロット攻撃:</strong> 揃った絵柄でダメージが変わる！防御時も同じルールでダメージを軽減できるぞ。攻撃するとレジェンドパワーが溜まる！</p>
                    <ul class="list-disc list-inside bg-blue-100 p-2 rounded-lg">
                        <li>1個も揃わない: 攻撃力 x 1倍 / ダメージそのまま</li>
                        <li>2個揃う: 攻撃力 x 1.8倍 / ダメージを 9/10 に軽減</li>
                        <li>3個揃う: 攻撃力 x 2.5倍 / ダメージを 6/10 に軽減</li>
                    </ul>
                    <p><strong>5. とくしゅのうりょく:</strong> レジェンドパワーが100まで溜まると使えるようになるぞ！スライムごとに違う強力な能力だ！</p>
                    <p><strong>6. ダメージ計算:</strong> 最終的なダメージから、相手の防御力÷3を引いた値が実際のダメージになる。</p>
                 </div>
             </div>
             <div class="text-center mt-4">
                <button onclick="showScreen('home-screen')" class="btn btn-secondary">戻る</button>
            </div>
        </div>

        <!-- Reset Confirmation Modal -->
        <div id="reset-confirm-modal" class="absolute inset-0 bg-black/50 hidden items-center justify-center p-4 z-50">
            <div class="card text-center">
                <h3 class="text-2xl font-bold">本当にリセットしますか？</h3>
                <p class="my-4 text-sm">すべてのセーブデータが消えてしまいます！</p>
                <div class="flex justify-center gap-4 mt-6">
                    <button onclick="executeReset()" class="btn bg-red-500 border-red-700">はい</button>
                    <button onclick="document.getElementById('reset-confirm-modal').style.display='none'" class="btn btn-secondary">いいえ</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getFirestore, collection, addDoc, query, where, getDocs, doc, onSnapshot, updateDoc, deleteDoc, serverTimestamp, writeBatch } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";

        let db, auth;
        let unsubscribeMatch = null; 
        let localUnsubscribe = null;

        async function checkFirebaseStatus() {
            const onlineBtn = document.getElementById('online-mode-btn');
            const statusText = document.getElementById('online-status-text');

            onlineBtn.classList.add('btn-disabled');
            statusText.textContent = 'サーバーに接続できません';
            statusText.style.color = 'red';
            onlineBtn.onclick = null;

            try {
                const firebaseConfig = {
                    apiKey: "AIzaSyA2SS_petftf_G5Dty4tJeQ9WYOt5_bXPI",
                    authDomain: "slimesensous.firebaseapp.com",
                    projectId: "slimesensous",
                    storageBucket: "slimesensous.firebasestorage.app",
                    messagingSenderId: "431777125771",
                    appId: "1:431777125771:web:e463caf55efdb5530b4b8e",
                    measurementId: "G-4DPQX55X16"
                };

                 if (!firebaseConfig.apiKey) {
                    throw new Error("Firebase config is missing apiKey.");
                }

                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        onlineBtn.classList.remove('btn-disabled');
                        onlineBtn.onclick = () => {
                             showScreen('online-lobby-screen');
                             document.getElementById('your-id-text').textContent = `あなたのID: ${user.uid}`;
                        };
                        statusText.textContent = 'サーバーに接続済み';
                        statusText.style.color = 'green';
                    } else {
                        onlineBtn.classList.add('btn-disabled');
                        statusText.textContent = 'サーバーに接続できません (認証失敗)';
                        statusText.style.color = 'red';
                        onlineBtn.onclick = null;
                    }
                });
                
                await signInAnonymously(auth);

            } catch (error) {
                console.error("Firebase connection failed:", error);
                statusText.textContent = '現在はサーバーに接続できません (初期化失敗)';
            }
        }

        // --- オンライン対戦ロジック (改修) ---
        async function updateMatchInFirestore(updateData) {
            if (gameState.onlineMatchId) {
                const matchRef = doc(db, "matches", gameState.onlineMatchId);
                await updateDoc(matchRef, updateData);
            }
        }

        window.startMatching = async () => {
            if (player.party.length === 0) {
                alert('オンライン対戦にはパーティ編成が必要です。'); return;
            }
            const matchingBtn = document.getElementById('start-matching-btn');
            matchingBtn.classList.add('hidden');
            document.getElementById('matching-loader').classList.remove('hidden');
            document.getElementById('lobby-message').textContent = '対戦相手を探しています...';

            const matchesRef = collection(db, "matches");
            const q = query(matchesRef, where("status", "==", "waiting"));
            const querySnapshot = await getDocs(q);
            
            let matchFound = false;
            if (!querySnapshot.empty) {
                for (const d of querySnapshot.docs) {
                    if (d.data().player1_uid !== auth.currentUser.uid) {
                        matchFound = true;
                        await joinMatch(d.id);
                        break;
                    }
                }
            }

            if (!matchFound) {
                await createMatch();
            }
        };

        const createMatch = async () => {
             try {
                const matchRef = await addDoc(collection(db, "matches"), {
                    player1_uid: auth.currentUser.uid,
                    player1_party: player.party,
                    player2_uid: null,
                    player2_party: null,
                    status: 'waiting',
                    createdAt: serverTimestamp(),
                    turn: null,
                    phase: null,
                    lastAction: null,
                    winner: null,
                });
                listenToMatch(matchRef.id);
            } catch (e) {
                console.error("Error creating match: ", e);
                cancelMatching();
            }
        };

        const joinMatch = async (matchId) => {
            try {
                const matchRef = doc(db, "matches", matchId);
                const batch = writeBatch(db);
                batch.update(matchRef, {
                    player2_uid: auth.currentUser.uid,
                    player2_party: player.party,
                    status: 'active',
                    turn: 'mash', // マッチング成功、連打勝負へ
                });
                await batch.commit();
                listenToMatch(matchId);
            } catch(e) {
                console.error("Error joining match:", e);
                cancelMatching();
            }
        };
        
        const listenToMatch = (matchId) => {
            if (localUnsubscribe) localUnsubscribe(); // 前のリスナーを解除
            gameState.onlineMatchId = matchId;
            const matchRef = doc(db, "matches", matchId);
            localUnsubscribe = onSnapshot(matchRef, (doc) => {
                const matchData = doc.data();
                if (!matchData || matchData.status === 'canceled') {
                    if (gameState.battle) { // バトル中に相手が切断
                        alert("相手が対戦から離脱しました。");
                        endBattle();
                    } else {
                        cancelMatching();
                    }
                    return;
                }

                if (matchData.status === 'active' && !gameState.battle) {
                    startOnlineBattle(matchData, matchId);
                } else if (gameState.battle) {
                    syncGameState(matchData);
                }
            });
        };

        window.cancelMatching = async () => {
            if (localUnsubscribe) {
                localUnsubscribe();
                localUnsubscribe = null;
            }
            if (gameState.onlineMatchId) {
                const matchRef = doc(db, "matches", gameState.onlineMatchId);
                await updateDoc(matchRef, { status: 'canceled' }).catch(()=>{});
                gameState.onlineMatchId = null;
            }
            const matchingBtn = document.getElementById('start-matching-btn');
            if (matchingBtn) {
                matchingBtn.classList.remove('hidden');
                document.getElementById('matching-loader').classList.add('hidden');
                document.getElementById('lobby-message').textContent = '対戦相手を探します';
            }
        };

        const startOnlineBattle = (matchData, matchId) => {
            const isPlayer1 = matchData.player1_uid === auth.currentUser.uid;
            const opponentUid = isPlayer1 ? matchData.player2_uid : matchData.player1_uid;
            
            gameState.battle = {
                online: true, isPlayer1, matchId, opponentUid,
                playerTeam: isPlayer1 ? matchData.player1_party : matchData.player2_party,
                enemyTeam: isPlayer1 ? matchData.player2_party : matchData.player1_party,
                playerTotalStats: calculateTeamStats(isPlayer1 ? matchData.player1_party : matchData.player2_party),
                enemyTotalStats: calculateTeamStats(isPlayer1 ? matchData.player2_party : matchData.player1_party),
                turn: matchData.turn, phase: 'attack',
                playerLegendPower: 0, legendPowerMax: 100,
                lastAction: null,
            };
            gameState.battle.playerTotalStats.currentHp = gameState.battle.playerTotalStats.hp;
            gameState.battle.enemyTotalStats.currentHp = gameState.battle.enemyTotalStats.hp;

            document.getElementById('player-name').textContent = `あなた`;
            document.getElementById('enemy-name').textContent = `あいて`;
            
            setupBattleUI();
            showScreen('battle-screen');
            
            if (matchData.turn === 'mash') {
                 startMashBattle();
            } else {
                syncGameState(matchData);
            }
        };

        function syncGameState(matchData) {
            if (!gameState.battle || !matchData) return;
            const battle = gameState.battle;
            
            // HPやステータスを同期
            const myKey = battle.isPlayer1 ? 'player1' : 'player2';
            const enemyKey = battle.isPlayer1 ? 'player2' : 'player1';
            
            if(matchData[myKey+'_currentHp'] !== undefined) battle.playerTotalStats.currentHp = matchData[myKey+'_currentHp'];
            if(matchData[enemyKey+'_currentHp'] !== undefined) battle.enemyTotalStats.currentHp = matchData[enemyKey+'_currentHp'];
            if(matchData[myKey+'_legendPower'] !== undefined) battle.playerLegendPower = matchData[myKey+'_legendPower'];
            
            battle.turn = matchData.turn;
            battle.phase = matchData.phase;
            battle.lastAction = matchData.lastAction;
            
            updateHpBars();
            updateLegendPowerBar();

            if (matchData.winner) {
                battle.winner = matchData.winner;
                endBattle();
                return;
            }

            // UIの更新
            if (battle.turn === auth.currentUser.uid) { // 自分のターン
                 if (battle.phase === 'defense') {
                    setBattleMessage(`相手が攻撃してきた！ (${battle.lastAction.matchCount}個) 防御しろ！`);
                    document.getElementById('battle-actions-area').style.display = 'none';
                    document.getElementById('slot-machine-area').style.display = 'flex';
                    startSlotMachine();
                 } else { // attack phase
                    setBattleMessage('あなたのターン！');
                    document.getElementById('battle-actions-area').style.display = 'flex';
                    document.getElementById('slot-machine-area').style.display = 'none';
                    document.getElementById('special-select-area').style.display = 'none';
                 }
            } else { // 相手のターン
                setBattleMessage('相手のターン...');
                document.getElementById('battle-actions-area').style.display = 'none';
                document.getElementById('slot-machine-area').style.display = 'none';
                document.getElementById('special-select-area').style.display = 'none';
            }
        }


        // --- ゲームロジック (既存) ---

        const slimeTypeColors = {
            '基本': '#a3e635', '火': '#f97316', '水': '#38bdf8', '風': '#34d399', 
            '地': '#a16207', '光': '#facc15', '闇': '#a21caf', 'メタル': '#9ca3af', 
            'アンデッド': '#7c3aed', '自然': '#22c55e', '魔法': '#ec4899', 
            '機械': '#64748b', '特殊': '#d946ef', '伝説': 'linear-gradient(45deg, #fde047, #f97316, #ec4899, #8b5cf6)', 
            '神': 'linear-gradient(45deg, #e5e7eb, #fefce8, #e5e7eb)'
        };
        const slotItems = ['🔥', '💧', '🌿', '🔩', '💀'];
        
        let allSlimes = [];
        let synthesisState = { base: null, material: null };

        function generateSlimeDatabase() {
            const slimes = [
                // 基本種
                { no: 1, name: 'スライム', hp: 100, atk: 10, def: 10, type: '基本', rarity: 'N', ability: { name: '体当たり', desc: '敵単体に小ダメージ', type: 'damage', power: 1.2 } },
                { no: 2, name: 'ビッグスライム', hp: 300, atk: 25, def: 20, type: '基本', rarity: 'R', ability: { name: 'ぷるぷるプレス', desc: '敵単体に中ダメージ', type: 'damage', power: 2.0 } },
                { no: 3, name: 'キングスライム', hp: 1000, atk: 80, def: 70, type: '基本', rarity: 'SR', ability: { name: '王の号令', desc: '味方全体の攻撃力アップ', type: 'buff_atk', power: 1.2, turns: 3 } },
                { no: 4, name: 'エンペラースライム', hp: 3200, atk: 250, def: 220, type: '基本', rarity: 'SSR', ability: { name: '皇帝の威厳', desc: '味方全体の防御力アップ', type: 'buff_def', power: 1.3, turns: 3 } },
                // 火属性
                { no: 12, name: 'ファイアスライム', hp: 150, atk: 20, def: 12, type: '火', rarity: 'N', ability: { name: 'ファイアボール', desc: '敵単体に火の小ダメージ', type: 'damage', power: 1.5 } },
                { no: 13, name: 'マグマスライム', hp: 500, atk: 60, def: 80, type: '火', rarity: 'R', ability: { name: '火傷付与', desc: '敵単体に大ダメージ', type: 'damage', power: 2.2 } },
                // 水属性
                { no: 20, name: 'アクアスライム', hp: 180, atk: 15, def: 18, type: '水', rarity: 'N', ability: { name: 'スプラッシュ', desc: '敵単体に水の小ダメージ', type: 'damage', power: 1.5 } },
                { no: 21, name: 'ヒーリングスライム', hp: 300, atk: 10, def: 40, type: '水', rarity: 'R', ability: { name: 'ヒール', desc: '味方単体のHPを小回復', type: 'heal', power: 100 } },
                // メタル
                { no: 101, name: 'メタルスライム', hp: 50, atk: 5, def: 500, type: 'メタル', rarity: 'R', ability: { name: '高速回避', desc: '何も起こらない', type: 'none' } },
                { no: 103, name: 'ダイヤモンドスライム', hp: 800, atk: 150, def: 3000, type: 'メタル', rarity: 'SSR', ability: { name: '絶対防御', desc: '味方全体の防御を超アップ', type: 'buff_def', power: 1.8, turns: 2 } },
                // アンデッド
                { no: 180, name: 'ゾンビスライム', hp: 400, atk: 45, def: 30, type: 'アンデッド', rarity: 'R', ability: { name: 'リヴァイブ', desc: '何も起こらない', type: 'none' } },
                { no: 183, name: 'リッチスライム', hp: 2800, atk: 320, def: 250, type: 'アンデッド', rarity: 'SSR', ability: { name: 'デッドリーカース', desc: '敵単体に闇の大ダメージ', type: 'damage', power: 3.5 } },
                 // 伝説
                { no: 585, name: '虹龍神スライム', hp: 8888, atk: 888, def: 888, type: '伝説', rarity: 'UR', ability: { name: '七色の奇跡', desc: '味方全体のHPを全回復', type: 'full_heal' } },
                { no: 586, name: '虚無のスライム', hp: 10000, atk: 1000, def: 1000, type: '伝説', rarity: 'UR', ability: { name: '存在抹消', desc: '敵単体に超絶ダメージ', type: 'damage', power: 5.0 } },
                { no: 587, name: '創造主のスライム', hp: 99999, atk: 2500, def: 2500, type: '神', rarity: 'UR', ability: { name: '世界創造', desc: '味方全体を全回復し、攻撃防御アップ', type: 'special_buff_heal' } }
            ];
            
            const existingNos = new Set(slimes.map(s => s.no));
            let currentNo = 1;
            const types = ['火', '水', '風', '地', '光', '闇', '自然', '魔法', '機械', '特殊'];
            const names1 = ['プチ', 'ノーマル', 'ハイ', 'ギガ', 'テラ', 'ゴッド'];
            const names2 = ['ナイト', 'メイジ', 'アーチャー', 'シーカー', 'バーサーカー'];

            while(slimes.length < 587) {
                while(existingNos.has(currentNo)) { currentNo++; }
                const type = types[Math.floor(Math.random() * types.length)];
                const rank = Math.floor(Math.random() * names1.length);
                const job = names2[Math.floor(Math.random() * names2.length)];
                const name = `${names1[rank]}${job}スライム`;
                const stat_base = Math.pow(10, rank + 1);
                const hp = Math.floor(stat_base * (Math.random() * 2 + 3));
                const atk = Math.floor(stat_base * (Math.random() * 1 + 0.5));
                const def = Math.floor(stat_base * (Math.random() * 1 + 0.5));
                let rarity = 'N';
                if (rank >= 2) rarity = 'R'; // ハイ
                if (rank >= 4) rarity = 'SR'; // テラ
                if (rank >= 5) rarity = 'SSR';// ゴッド
                slimes.push({ no: currentNo, name, hp, atk, def, type, rarity, ability: { name: 'ランダムアタック', desc: '敵にダメージ', type: 'damage', power: 1.5 + rank * 0.4 } });
                existingNos.add(currentNo);
            }
            return slimes.sort((a,b) => a.no - b.no);
        }

        function createSlimeHTML(slime, isEnemy = false) {
            if (!slime) return ''; // バグ防止
            const bgColor = slimeTypeColors[slime.type] || '#d1d5db';
            const bodyStyle = slime.type === '伝説' || slime.type === '神' ? `background: ${bgColor};` : `background-color: ${bgColor};`;
            const enemyClass = isEnemy ? 'transform: scaleX(-1);' : '';
            const plusValue = slime.plus > 0 ? `<div class="plus-value">+${slime.plus}</div>` : '';
            return `
                <div class="slime-icon" style="${enemyClass}">
                    <div class="slime-body" style="${bodyStyle}">
                        <div class="slime-eyes"><div class="slime-eye"></div><div class="slime-eye"></div></div>
                    </div>
                    ${plusValue}
                </div>
            `;
        }
        
        function createNewSlimeInstance(baseSlime) {
            return {
                ...baseSlime,
                uniqueId: Date.now() + Math.random(),
                plus: 0
            };
        }

        allSlimes = generateSlimeDatabase();
        
        const gachaSlimes = allSlimes.filter(s => s.type !== '基本');

        let player = { slimes: [], party: [], coins: 30, storyProgress: 1 };
        const gameState = { currentScreen: 'loading-screen', battle: null, onlineMatchId: null };

        window.showScreen = (screenId) => {
            // ★修正: 合成画面から離れるときに選択をリセットする
            if (gameState.currentScreen === 'synthesis-screen' && screenId !== 'synthesis-screen') {
                synthesisState = { base: null, material: null };
            }

            document.getElementById(gameState.currentScreen).classList.remove('active');
            document.getElementById(screenId).classList.add('active');
            gameState.currentScreen = screenId;
            if (screenId === 'collection-screen') updateCollectionScreen();
            if (screenId === 'gacha-screen') updateGachaScreen();
            if (screenId === 'story-map-screen') updateStoryMap();
            if (screenId === 'party-formation-screen') updatePartyFormationScreen();
            if (screenId === 'synthesis-screen') updateSynthesisScreen();
        }

        function saveGame() {
            localStorage.setItem('slimeWarSave', JSON.stringify({
                slimes: player.slimes,
                party: player.party.map(s => s.uniqueId),
                coins: player.coins,
                storyProgress: player.storyProgress,
            }));
        }

        function loadGame() {
            const saveData = localStorage.getItem('slimeWarSave');
            if (saveData) {
                try {
                    const loaded = JSON.parse(saveData);

                    // 古いセーブデータ形式かチェックし、無効化する
                    if (!loaded.slimes || loaded.slimes.length === 0 || typeof loaded.slimes[0] !== 'object' || loaded.slimes[0].uniqueId === undefined) {
                        console.log("古いか無効なセーブデータです。新しいゲームを開始します。");
                        localStorage.removeItem('slimeWarSave'); // 不正なデータを削除
                        return false;
                    }

                    player.slimes = loaded.slimes;
                    player.party = loaded.party ? loaded.party.map(uid => player.slimes.find(s => s.uniqueId === uid)).filter(Boolean) : player.slimes.slice(0, 3);
                    player.coins = loaded.coins;
                    player.storyProgress = loaded.storyProgress;
                    return true;
                } catch (e) {
                    console.error("セーブデータの読み込みに失敗しました:", e);
                    localStorage.removeItem('slimeWarSave'); // 壊れたデータを削除
                    return false;
                }
            }
            return false;
        }

        window.onload = async () => {
            if (!loadGame()) {
                showScreen('partner-select-screen');
                setupPartnerSelection();
            } else {
                if(player.party.length === 0 && player.slimes.length > 0) {
                   player.party = player.slimes.slice(0,1);
                }
                showScreen('home-screen');
            }
            await checkFirebaseStatus();
            document.getElementById('loading-screen').classList.remove('active');
        };
        
        function setupPartnerSelection() {
            const optionsContainer = document.getElementById('partner-options');
            const partners = [allSlimes.find(s=>s.no===1), allSlimes.find(s=>s.no===12), allSlimes.find(s=>s.no===20)];
            let selectedPartnerNo = partners[0].no;
            
            optionsContainer.innerHTML = partners.map(slime => `
                <div class="partner-card border-4 border-transparent p-2 rounded-2xl cursor-pointer" data-no="${slime.no}">
                    ${createSlimeHTML(slime)}
                    <p class="font-bold text-center mt-2">${slime.name}</p>
                </div>
            `).join('');
            
            const cards = optionsContainer.querySelectorAll('.partner-card');
            cards[0].classList.replace('border-transparent', 'border-blue-500');

            cards.forEach(card => card.addEventListener('click', () => {
                cards.forEach(c => c.classList.replace('border-blue-500', 'border-transparent'));
                card.classList.replace('border-transparent', 'border-blue-500');
                selectedPartnerNo = parseInt(card.dataset.no);
            }));

            document.getElementById('confirm-partner-btn').onclick = () => {
                const chosenSlime = createNewSlimeInstance(allSlimes.find(s => s.no === selectedPartnerNo));
                player.slimes.push(chosenSlime);
                player.party = [chosenSlime];
                saveGame();
                showScreen('home-screen');
            };
        }

        function updatePartyFormationScreen() {
            const partyContainer = document.getElementById('current-party-display');
            const ownedContainer = document.getElementById('owned-slimes-list');

            const totalStats = player.party.reduce((acc, s) => {
                acc.hp += s.hp; acc.atk += s.atk; acc.def += s.def; return acc;
            }, {hp: 0, atk: 0, def: 0});

            document.getElementById('party-total-stats').innerHTML = `
                <span class="text-green-600">H:${totalStats.hp}</span>
                <span class="text-red-600">A:${totalStats.atk}</span>
                <span class="text-blue-600">D:${totalStats.def}</span>
            `;

            partyContainer.innerHTML = player.party.map(slime => `
                <div class="text-center p-1 bg-blue-200 rounded-lg cursor-pointer" onclick="removeFromParty('${slime.uniqueId}')">
                    ${createSlimeHTML(slime)}
                    <p class="text-xs font-bold truncate">${slime.name}</p>
                    <div class="text-[9px] leading-tight">
                        <span class="text-green-600">H:${slime.hp}</span>
                        <span class="text-red-600">A:${slime.atk}</span>
                        <span class="text-blue-600">D:${slime.def}</span>
                    </div>
                </div>
            `).join('');

            const nonPartySlimes = player.slimes.filter(s => !player.party.some(p => p.uniqueId === s.uniqueId));
            ownedContainer.innerHTML = nonPartySlimes.map(slime => `
                 <div class="text-center p-1 bg-white rounded-lg cursor-pointer" onclick="addToParty('${slime.uniqueId}')">
                    ${createSlimeHTML(slime)}
                    <p class="text-[10px] font-bold truncate">${slime.name}</p>
                    <div class="text-[9px] leading-tight">
                        <span class="text-green-600">H:${slime.hp}</span>
                        <span class="text-red-600">A:${slime.atk}</span>
                        <span class="text-blue-600">D:${slime.def}</span>
                    </div>
                </div>
            `).join('');
        }

        window.addToParty = (slimeUniqueId) => {
            if (player.party.length < 3) {
                const slimeToAdd = player.slimes.find(s => s.uniqueId == slimeUniqueId);
                player.party.push(slimeToAdd);
                saveGame();
                updatePartyFormationScreen();
            } else {
                alert('パーティは3匹までです。');
            }
        }

        window.removeFromParty = (slimeUniqueId) => {
            player.party = player.party.filter(s => s.uniqueId != slimeUniqueId);
            saveGame();
            updatePartyFormationScreen();
        }
        
        // --- Synthesis Logic ---
        function updateSynthesisScreen() {
            const baseContainer = document.getElementById('synthesis-base');
            const materialContainer = document.getElementById('synthesis-material');
            const resultPreview = document.getElementById('synthesis-result-preview');
            const executeBtn = document.getElementById('execute-synthesis-btn');
            const slimesList = document.getElementById('synthesis-slimes-list');
            
            baseContainer.innerHTML = synthesisState.base ? `
                ${createSlimeHTML(synthesisState.base)}
                <p class="text-xs font-bold truncate">${synthesisState.base.name}</p>
            ` : '<p class="text-sm">ベース</p>';

            materialContainer.innerHTML = synthesisState.material ? `
                ${createSlimeHTML(synthesisState.material)}
                <p class="text-xs font-bold truncate">${synthesisState.material.name}</p>
            ` : '<p class="text-sm">素材</p>';

            if (synthesisState.base && synthesisState.material) {
                const base = synthesisState.base;
                const material = synthesisState.material;
                const baseInfo = allSlimes.find(s => s.no === material.no);

                const hpUp = Math.floor(baseInfo.hp * 0.1);
                const atkUp = Math.floor(baseInfo.atk * 0.1);
                const defUp = Math.floor(baseInfo.def * 0.1);

                resultPreview.innerHTML = `
                    <p class="font-bold">合成結果</p>
                    <p class="text-sm">
                        <span class="text-green-600">HP ${base.hp} → ${base.hp + hpUp} (+${hpUp})</span><br>
                        <span class="text-red-600">ATK ${base.atk} → ${base.atk + atkUp} (+${atkUp})</span><br>
                        <span class="text-blue-600">DEF ${base.def} → ${base.def + defUp} (+${defUp})</span>
                    </p>
                `;
                executeBtn.classList.remove('btn-disabled');
            } else {
                resultPreview.innerHTML = '';
                executeBtn.classList.add('btn-disabled');
            }
            
            slimesList.innerHTML = player.slimes.map(slime => `
                <div class="text-center p-1 bg-white rounded-lg cursor-pointer border-2 ${synthesisState.base?.uniqueId === slime.uniqueId ? 'border-blue-500' : (synthesisState.material?.uniqueId === slime.uniqueId ? 'border-gray-500' : 'border-transparent')}" 
                     onclick="selectSynthesisSlime('${slime.uniqueId}')">
                    ${createSlimeHTML(slime)}
                    <p class="text-[10px] font-bold truncate">${slime.name}</p>
                </div>
            `).join('');
        }
        
        window.selectSynthesisSlime = (uniqueId) => {
            const slime = player.slimes.find(s => s.uniqueId == uniqueId);
            if (!synthesisState.base || synthesisState.base.uniqueId == uniqueId) {
                synthesisState.base = slime;
                synthesisState.material = null; // ベースを選び直したら素材はリセット
            } else if (synthesisState.base.no === slime.no) { // 同じ種類のスライムのみ素材にできる
                synthesisState.material = slime;
            } else {
                alert('同じ種類のスライムしか素材にできません。');
            }
            updateSynthesisScreen();
        };

        document.getElementById('execute-synthesis-btn').onclick = () => {
            if (!synthesisState.base || !synthesisState.material) return;

            const base = synthesisState.base;
            const material = synthesisState.material;
            const rarityCost = {'N': 10, 'R': 20, 'SR': 50, 'SSR': 100, 'UR': 500};
            const cost = (rarityCost[base.rarity] || 10) * (base.plus + 1);

            if (player.coins < cost) {
                alert(`コインが足りません！(${cost}コイン必要)`);
                return;
            }

            player.coins -= cost;
            const baseInfo = allSlimes.find(s => s.no === material.no);

            base.hp += Math.floor(baseInfo.hp * 0.1);
            base.atk += Math.floor(baseInfo.atk * 0.1);
            base.def += Math.floor(baseInfo.def * 0.1);
            base.plus += 1;

            // 素材を削除
            player.slimes = player.slimes.filter(s => s.uniqueId !== material.uniqueId);
            // パーティからも素材を削除
            player.party = player.party.filter(s => s.uniqueId !== material.uniqueId);

            synthesisState = { base: null, material: null };
            saveGame();
            updateSynthesisScreen();
            alert('合成成功！');
        };

        function updateCollectionScreen() {
            const grid = document.getElementById('collection-grid');
            grid.innerHTML = allSlimes.map(slime => {
                const ownedInstances = player.slimes.filter(s => s.no === slime.no);
                const owned = ownedInstances.length > 0;
                const slimeHTML = createSlimeHTML(slime);
                if (owned) {
                     const strongest = ownedInstances.reduce((max, s) => (s.plus > max.plus ? s : max), ownedInstances[0]);
                    return `
                        <div class="text-center p-1 rounded-lg bg-blue-200 flex flex-col justify-between">
                            <p class="text-[10px] font-bold">${slime.no}:${slime.name}</p>
                            <div class="mx-auto w-16 h-16 flex justify-center items-center">${createSlimeHTML(strongest)}</div>
                            <div class="text-[9px] leading-tight mt-1">
                                <span class="text-green-600">H:${slime.hp}</span><br>
                                <span class="text-red-600">A:${slime.atk}</span>
                                <span class="text-blue-600">D:${slime.def}</span>
                            </div>
                        </div>
                    `;
                } else {
                    return `
                        <div class="text-center p-1 rounded-lg bg-gray-200 flex flex-col justify-between">
                            <p class="text-[10px] font-bold text-gray-400">${slime.no}:？？？</p>
                            <div class="mx-auto w-16 h-16 flex justify-center items-center opacity-25">${slimeHTML}</div>
                             <div class="text-[9px] leading-tight mt-1 text-gray-400">
                                <span>H:???</span><br>
                                <span>A:???</span>
                                <span>D:???</span>
                            </div>
                        </div>
                    `;
                }
            }).join('');
        }
        
        function updateGachaScreen() {
            document.getElementById('gacha-coin-count').textContent = player.coins;
        }

        function updateStoryMap() {
            const stageList = document.getElementById('stage-list');
            stageList.innerHTML = Array.from({length: 76}, (_, i) => i + 1).map(i => {
                const isCleared = i < player.storyProgress, isCurrent = i === player.storyProgress;
                let stageClass = `bg-gray-300 text-gray-500 ${isCurrent ? 'cursor-pointer' : 'cursor-not-allowed'}`;
                if (isCleared) stageClass = 'bg-yellow-400 text-white';
                if (isCurrent) stageClass = 'bg-blue-500 text-white animate-pulse';
                return `<button onclick="${isCurrent ? `startBattle(${i})` : ''}" class="w-12 h-12 rounded-full flex items-center justify-center font-bold text-lg ${stageClass}">${i}</button>`;
            }).join('');
        }
        
        function performGacha(count) {
            const cost = count === 10 ? 80 : 10;
            if (player.coins < cost) { alert('コインが足りません！'); return; }
            player.coins -= cost;

            const animationScreen = document.getElementById('gacha-animation-screen');
            const chest = animationScreen.querySelector('.gacha-chest');
            const light = animationScreen.querySelector('.gacha-light');
            showScreen('gacha-animation-screen');

            chest.textContent = '🎁';
            chest.classList.add('shaking');
            
            setTimeout(() => {
                chest.classList.remove('shaking');
                chest.textContent = '✨';
                light.classList.add('glowing');

                setTimeout(() => {
                    let hpLimit = Infinity, atkLimit = Infinity;
                    if (player.storyProgress < 50) {
                        if (player.storyProgress <= 10) { hpLimit = 800; atkLimit = 100; } 
                        else if (player.storyProgress <= 20) { hpLimit = 2000; atkLimit = 300; } 
                        else if (player.storyProgress <= 49) { hpLimit = 5000; atkLimit = 500; }
                    }
                    const availableGachaSlimes = gachaSlimes.filter(s => s.hp <= hpLimit && s.atk <= atkLimit);

                    const rarityPools = { N: [], R: [], SR: [], SSR: [], UR: [] };
                    availableGachaSlimes.forEach(s => {
                        if (rarityPools[s.rarity]) rarityPools[s.rarity].push(s);
                    });

                    let rates = { N: 0.70, R: 0.23, SR: 0.05, SSR: 0.015, UR: 0.005 };
                    const progressBonus = Math.min(0.15, player.storyProgress / 76 * 0.15); 
                    rates.N -= progressBonus;
                    rates.R += progressBonus * 0.7;
                    rates.SR += progressBonus * 0.2;
                    rates.SSR += progressBonus * 0.08;
                    rates.UR += progressBonus * 0.02;

                    const pullSlime = () => {
                        const roll = Math.random();
                        let cumulative = 0;
                        for (const rarity in rates) {
                            cumulative += rates[rarity];
                            if (roll < cumulative) {
                                const pool = rarityPools[rarity];
                                if (pool && pool.length > 0) return pool[Math.floor(Math.random() * pool.length)];
                            }
                        }
                        const fallbackPool = rarityPools['N'] || availableGachaSlimes.filter(s => s.rarity === 'N');
                        return fallbackPool[Math.floor(Math.random() * fallbackPool.length)];
                    };
                    
                    const results = Array.from({length: count}, () => pullSlime());
                    const processedResults = [];

                    results.forEach(pulledSlime => {
                        if (!pulledSlime) return;
                        const newInstance = createNewSlimeInstance(pulledSlime);
                        player.slimes.push(newInstance);
                        processedResults.push({ slime: newInstance, isNew: true });
                    });
                    
                    saveGame();
                    updateGachaScreen();
                    
                    const resultGrid = document.getElementById('gacha-result-grid');
                    resultGrid.innerHTML = processedResults.map(res => `
                        <div class="text-center relative p-1 rounded-lg bg-yellow-200">
                            ${createSlimeHTML(res.slime)}
                            <p class="text-xs truncate font-bold">${res.slime.name}</p>
                        </div>
                    `).join('');
                    document.getElementById('gacha-result-modal').style.display = 'flex';

                    chest.textContent = '🎁';
                    light.classList.remove('glowing');
                    showScreen('gacha-screen');
                }, 1500);

            }, 500);
        }
        
        document.getElementById('gacha-single-btn').onclick = () => performGacha(1);
        document.getElementById('gacha-multi-btn').onclick = () => performGacha(10);
        
        // --- Battle Logic ---
        window.startBattle = (stage) => {
            if (player.party.length === 0) { alert("パーティにスライムがいません！"); return; }
            document.getElementById('player-name').textContent = `あなた`;
            document.getElementById('enemy-name').textContent = `てき`;

            let enemyPool = [];
            let enemyCount = 1;
            let scale = 1.0;

            // --- 新しいステージ難易度調整ロジック ---
            if (stage <= 5) {
                // ステージ1-5: チュートリアル的な難易度
                enemyPool = allSlimes.filter(s => s.hp < 350 && s.rarity === 'N');
                enemyCount = 1 + Math.floor((stage - 1) / 2); // 1, 2, 2, 3, 3匹
                scale = 0.8 + stage * 0.1; // 0.9 to 1.3
            } else if (stage <= 15) {
                // ステージ6-15: 序盤
                enemyPool = allSlimes.filter(s => s.hp < 1200 && (s.rarity === 'N' || s.rarity === 'R'));
                enemyCount = 3;
                scale = 1.0 + (stage - 5) * 0.15; // 1.15 to 2.5
            } else if (stage <= 30) {
                // ステージ16-30: 中盤
                enemyPool = allSlimes.filter(s => s.hp < 4000 && (s.rarity === 'R' || s.rarity === 'SR'));
                enemyCount = 3;
                scale = 2.0 + (stage - 15) * 0.2; // 2.2 to 5.0
            } else {
                // ステージ31以降: 終盤
                enemyPool = allSlimes.filter(s => s.rarity !== 'N'); // Nはもう出ない
                enemyCount = 3;
                scale = 4.0 + (stage - 30) * 0.25; // 4.25+
            }
            
            // 念のためプールが空の場合は弱いスライムで埋める
            if (enemyPool.length === 0) {
                enemyPool.push(allSlimes.find(s => s.no === 1));
            }
            // --- 調整ここまで ---

            const enemyTeam = Array.from({length: enemyCount}, () => {
                let et = { ...enemyPool[Math.floor(Math.random() * enemyPool.length)] };
                // ステータスをスケール
                et.hp = Math.max(10, Math.floor(et.hp * scale));
                et.atk = Math.max(5, Math.floor(et.atk * scale));
                et.def = Math.max(5, Math.floor(et.def * scale));
                return et;
            });

            gameState.battle = {
                online: false, stage, playerTeam: JSON.parse(JSON.stringify(player.party)), enemyTeam,
                playerTotalStats: calculateTeamStats(player.party),
                enemyTotalStats: calculateTeamStats(enemyTeam),
                turn: 'mash', phase: 'attack',
                playerLegendPower: 0, legendPowerMax: 100
            };
            gameState.battle.playerTotalStats.currentHp = gameState.battle.playerTotalStats.hp;
            gameState.battle.enemyTotalStats.currentHp = gameState.battle.enemyTotalStats.hp;
            setupBattleUI();
            showScreen('battle-screen');
            startMashBattle();
        };

        function calculateTeamStats(team) {
            return team.reduce((acc, slime) => {
                acc.hp += slime.hp; acc.atk += slime.atk; acc.def += slime.def; return acc;
            }, { hp: 0, atk: 0, def: 0 });
        }
        
        function setupBattleUI() {
            const { playerTeam, enemyTeam } = gameState.battle;
            document.getElementById('player-area').querySelector('.flex').innerHTML = playerTeam.map(s => createSlimeHTML(s)).join('');
            document.getElementById('enemy-area').querySelector('.flex').innerHTML = enemyTeam.map(s => createSlimeHTML(s, true)).join('');
            updateHpBars();
            updateLegendPowerBar();
        }

        function updateHpBars() {
            const { playerTotalStats, enemyTotalStats } = gameState.battle;
            const playerHpPercent = Math.max(0, (playerTotalStats.currentHp / playerTotalStats.hp) * 100);
            const enemyHpPercent = Math.max(0, (enemyTotalStats.currentHp / enemyTotalStats.hp) * 100);
            document.getElementById('player-hp-bar').style.width = `${playerHpPercent}%`;
            document.getElementById('player-hp-text').textContent = `HP: ${playerTotalStats.currentHp} / ${playerTotalStats.hp}`;
            document.getElementById('enemy-hp-bar').style.width = `${enemyHpPercent}%`;
            document.getElementById('enemy-hp-text').textContent = `HP: ${enemyTotalStats.currentHp} / ${enemyTotalStats.hp}`;
        }
                
        function setBattleMessage(msg) { document.getElementById('battle-message').textContent = msg; }

        function updateLegendPowerBar() {
            const battle = gameState.battle; if (!battle) return;
            const percent = Math.min(100, (battle.playerLegendPower / battle.legendPowerMax) * 100);
            const bar = document.getElementById('legend-power-bar');
            if (bar) bar.style.width = `${percent}%`;
            const text = document.getElementById('legend-power-text');
            if(text) text.textContent = `レジェンドパワー: ${battle.playerLegendPower} / ${battle.legendPowerMax}`;

            const specialBtn = document.getElementById('special-btn');
            if (battle.playerLegendPower >= battle.legendPowerMax) {
                specialBtn.textContent = 'とくしゅのうりょく！';
                specialBtn.classList.remove('btn-disabled');
                specialBtn.classList.add('animate-pulse', 'bg-yellow-400', 'border-yellow-600');
            } else {
                specialBtn.textContent = 'とくしゅのうりょく';
                specialBtn.classList.add('btn-disabled');
                specialBtn.classList.remove('animate-pulse', 'bg-yellow-400', 'border-yellow-600');
            }
        }

        function chargeLegendPower(amount) {
            const battle = gameState.battle; if (!battle) return;
            battle.playerLegendPower = Math.min(battle.legendPowerMax, battle.playerLegendPower + amount);
            updateLegendPowerBar();
        }

        function battleTurn() { // Offline battle turn logic
            const battle = gameState.battle;
            if (battle.playerTotalStats.currentHp <= 0 || battle.enemyTotalStats.currentHp <= 0) { endBattle(); return; }
            
            if (battle.turn === 'player') {
                setBattleMessage('あなたのターン！');
                document.getElementById('battle-actions-area').style.display = 'flex';
                document.getElementById('slot-machine-area').style.display = 'none';
                document.getElementById('special-select-area').style.display = 'none';
            } else { // CPU turn
                setBattleMessage('相手のターン！');
                document.getElementById('battle-actions-area').style.display = 'none';
                if (Math.random() < 0.4) {
                    const cpuAttacker = battle.enemyTeam[Math.floor(Math.random() * battle.enemyTeam.length)];
                    setTimeout(() => {
                        setBattleMessage(`相手の${cpuAttacker.name}が${cpuAttacker.ability.name}を使った！`);
                        applyAbility(cpuAttacker.ability, 'enemy');
                        setTimeout(() => { battle.turn = 'player'; battleTurn(); }, 2000);
                    }, 1500);
                } else {
                    battle.enemyMatchCount = [1, 1, 2, 3][Math.floor(Math.random() * 4)];
                    setTimeout(() => {
                        battle.phase = 'defense'; 
                        setBattleMessage('相手が攻撃してくる！防御しろ！');
                        document.getElementById('slot-machine-area').style.display = 'flex';
                        startSlotMachine();
                    }, 1500);
                }
            }
        }
        
        document.getElementById('attack-btn').onclick = () => {
            gameState.battle.phase = 'attack';
            document.getElementById('battle-actions-area').style.display = 'none';
            document.getElementById('slot-machine-area').style.display = 'flex';
            startSlotMachine();
        };

        document.getElementById('special-btn').onclick = () => {
            const battle = gameState.battle;
            if (battle.playerLegendPower >= battle.legendPowerMax) {
                document.getElementById('battle-actions-area').style.display = 'none';
                const selectArea = document.getElementById('special-select-area');
                selectArea.innerHTML = gameState.battle.playerTeam.map((slime, i) => 
                    `<button onclick="useSpecialAbility(${i})" class="btn btn-special w-full text-sm">${slime.name}の「${slime.ability.name}」</button>`
                ).join('');
                selectArea.style.display = 'flex';
            } else {
                setBattleMessage('レジェンドパワーが足りない！');
            }
        };

        window.useSpecialAbility = (partyIndex) => {
            const slime = gameState.battle.playerTeam[partyIndex];
            setBattleMessage(`${slime.name}の「${slime.ability.name}」！`);
            applyAbility(slime.ability, 'player');
            gameState.battle.playerLegendPower = 0;
            updateLegendPowerBar();
            document.getElementById('special-select-area').style.display = 'none';
            
            if(gameState.battle.online) {
                const enemyUid = gameState.battle.isPlayer1 ? gameState.battle.enemyTeam.uid : gameState.battle.playerTeam.uid;
                // update firestore
            } else {
                 setTimeout(() => {
                    gameState.battle.turn = 'enemy';
                    battleTurn();
                }, 2000);
            }
        };

        function applyAbility(ability, caster) {
            const battle = gameState.battle;
            const [casterStats, targetStats] = caster === 'player' ? [battle.playerTotalStats, battle.enemyTotalStats] : [battle.enemyTotalStats, battle.playerTotalStats];
            let message = '';
            switch (ability.type) {
                case 'damage':
                    const damage = Math.max(0, Math.floor(casterStats.atk * ability.power - targetStats.def / 3));
                    targetStats.currentHp -= damage;
                    message = `${damage}のダメージ！`; break;
                case 'heal':
                    casterStats.currentHp = Math.min(casterStats.hp, casterStats.currentHp + ability.power);
                    message = `HPが${ability.power}回復した！`; break;
                case 'full_heal':
                     casterStats.currentHp = casterStats.hp;
                     message = 'HPが全回復した！'; break;
                case 'buff_atk': case 'buff_def':
                     message = `${caster==='player'?'味方':'敵'}の${ability.type.includes('atk')?'攻撃':'防御'}が上がった！`; break;
                case 'special_buff_heal':
                    casterStats.currentHp = casterStats.hp;
                    message = 'HPが全回復し、能力が上がった！'; break;
            }
            setBattleMessage(message);
            updateHpBars();
        }

        let reels = [], reelIntervals = [], stoppedReels = 0;
        function startSlotMachine() {
            document.querySelectorAll('.slot-item.matched').forEach(el => el.classList.remove('matched'));
            reels = [document.getElementById('reel1'), document.getElementById('reel2'), document.getElementById('reel3')];
            reelIntervals = []; stoppedReels = 0;
            
            reels.forEach((reel, i) => {
                let content = '';
                for(let j=0; j<20; j++) content += `<div class="slot-item">${slotItems[Math.floor(Math.random() * slotItems.length)]}</div>`;
                reel.innerHTML = content;
                reel.style.top = '0px';
                reel.style.transition = 'none'; // 回転中はトランジションをなくし、直接位置を更新
                reelIntervals[i] = setInterval(() => {
                    let top = parseInt(reel.style.top) - 20;
                    if (top < - (reel.scrollHeight - reel.parentElement.clientHeight)) top += reel.scrollHeight / 2;
                    reel.style.top = `${top}px`;
                }, 30);
            });
            document.getElementById('stop-btn').disabled = false;
        }

        document.getElementById('stop-btn').onclick = () => {
            if (stoppedReels < 3) {
                clearInterval(reelIntervals[stoppedReels]);
                const reel = reels[stoppedReels], reelContainer = reel.parentElement, items = reel.querySelectorAll('.slot-item');
                let closest = { el: null, dist: Infinity };
                items.forEach(item => {
                    const itemRect = item.getBoundingClientRect(), containerRect = reelContainer.getBoundingClientRect();
                    const dist = Math.abs((itemRect.top + itemRect.height / 2) - (containerRect.top + containerRect.height / 2));
                    if (dist < closest.dist) { closest.dist = dist; closest.el = item; }
                });
                const finalTop = -closest.el.offsetTop + (reelContainer.clientHeight - closest.el.clientHeight) / 2;
                
                // 停止時にトランジションを適用してスムーズに止める
                reel.style.transition = 'top 0.5s cubic-bezier(0.25, 1, 0.5, 1)';
                reel.style.top = `${finalTop}px`;
                stoppedReels++;
                if (stoppedReels === 3) {
                    document.getElementById('stop-btn').disabled = true;
                    setTimeout(calculateTurnResult, 1000);
                }
            }
        };

        function getSlotResultElements() {
            return reels.map(reel => {
                const items = reel.querySelectorAll('.slot-item');
                let closest = { el: null, dist: Infinity };
                items.forEach(item => {
                    const itemRect = item.getBoundingClientRect(), reelRect = reel.parentElement.getBoundingClientRect();
                    const dist = Math.abs((itemRect.top + itemRect.height / 2) - (reelRect.top + reelRect.height / 2));
                    if (dist < closest.dist) { closest.dist = dist; closest.el = item; }
                });
                return closest.el;
            });
        }
        
        async function calculateTurnResult() {
                const results = getSlotResultElements().map(el => el.textContent.trim());
                const counts = results.reduce((acc, val) => { acc[val] = (acc[val] || 0) + 1; return acc; }, {});
                const matchCount = results.length > 0 ? Math.max(...Object.values(counts)) : 1;

                if (matchCount > 1) {
                    let matchedValue = null;
                    for (const [value, count] of Object.entries(counts)) { if (count >= matchCount) { matchedValue = value; break; } }
                    if (matchedValue) {
                        getSlotResultElements().forEach(el => {
                            if (el.textContent.trim() === matchedValue) el.classList.add('matched');
                        });
                    }
                }
                const battle = gameState.battle;
                if (battle.online) {
                    const myKey = battle.isPlayer1 ? 'player1' : 'player2';
                    const enemyKey = battle.isPlayer1 ? 'player2' : 'player1';
                    const opponentUid = battle.opponentUid;

                    let updateData = {};
                    if (battle.phase === 'attack') {
                        let multiplier = 1;
                        if (matchCount === 2) multiplier = 1.8;
                        if (matchCount === 3) multiplier = 2.5;
                        const damage = Math.max(0, Math.floor(battle.playerTotalStats.atk * multiplier - battle.enemyTotalStats.def / 3));
                        battle.enemyTotalStats.currentHp -= damage;
                        const powerGained = 20 + Math.floor(Math.random() * 31);
                        chargeLegendPower(powerGained);

                        updateData.turn = opponentUid;
                        updateData.phase = 'defense';
                        updateData[enemyKey + '_currentHp'] = battle.enemyTotalStats.currentHp;
                        updateData[myKey + '_legendPower'] = battle.playerLegendPower;
                        updateData.lastAction = { type: 'slot_attack', matchCount: matchCount, damage: damage };
                    } else { // 'defense'
                        let reduction = 1;
                        if (matchCount === 2) reduction = 0.9;
                        if (matchCount === 3) reduction = 0.6;
                        
                        const enemyBaseAttack = battle.lastAction.damage; // Use damage from last action
                        let calculatedDamage = Math.floor(enemyBaseAttack * reduction);
                        const minDamage = Math.floor(enemyBaseAttack * 0.05);
                        if(calculatedDamage < minDamage) calculatedDamage = minDamage;
                        const enemyDamage = Math.max(1, calculatedDamage);

                        battle.playerTotalStats.currentHp -= enemyDamage;
                        
                        updateData.turn = opponentUid;
                        updateData.phase = 'attack';
                        updateData[myKey + '_currentHp'] = battle.playerTotalStats.currentHp;
                        updateData.lastAction = { type: 'slot_defense', matchCount: matchCount, finalDamage: enemyDamage };
                    }
                    if (battle.playerTotalStats.currentHp <= 0) updateData.winner = opponentUid;
                    if (battle.enemyTotalStats.currentHp <= 0) updateData.winner = auth.currentUser.uid;
                    
                    await updateMatchInFirestore(updateData);

                } else { // Offline
                    if (battle.phase === 'attack') { 
                        let multiplier = 1;
                        if (matchCount === 2) multiplier = 1.8;
                        if (matchCount === 3) multiplier = 2.5;
                        const damage = Math.max(0, Math.floor(battle.playerTotalStats.atk * multiplier - battle.enemyTotalStats.def / 3));
                        setBattleMessage(`${matchCount}個揃った！ ${damage} のダメージ！`);
                        battle.enemyTotalStats.currentHp -= damage;
                        const powerGained = 20 + Math.floor(Math.random() * 31);
                        chargeLegendPower(powerGained);
                        battle.turn = 'enemy';
                    } else { // 'defense'
                        let reduction = 1;
                        if (matchCount === 2) reduction = 0.9;
                        if (matchCount === 3) reduction = 0.6;
                        let enemyMultiplier = 1;
                        if (battle.enemyMatchCount === 2) enemyMultiplier = 1.8;
                        if (battle.enemyMatchCount === 3) enemyMultiplier = 2.5;
                        const enemyBaseAttack = battle.enemyTotalStats.atk * enemyMultiplier;

                        let calculatedDamage = Math.floor((enemyBaseAttack - battle.playerTotalStats.def / 3) * reduction);
                        const minDamage = Math.floor(enemyBaseAttack * 0.05); // 5% minimum damage
                        if (calculatedDamage < minDamage) {
                            calculatedDamage = minDamage;
                        }
                        const enemyDamage = Math.max(1, calculatedDamage); // Always deal at least 1 damage
                        
                        setBattleMessage(`${matchCount}個で防御！ ${enemyDamage} のダメージを受けた！`);
                        battle.playerTotalStats.currentHp -= enemyDamage;
                        battle.turn = 'player';
                    }
                    updateHpBars();
                    setTimeout(battleTurn, 2000);
                }
        }

        function endBattle() {
            const battle = gameState.battle;
            if(!battle) return;
            const modal = document.getElementById('battle-result-modal');
            const title = document.getElementById('result-title');
            const rewards = document.getElementById('result-rewards');

            if (battle.online) {
                const iAmWinner = battle.winner === auth.currentUser.uid;
                title.textContent = iAmWinner ? "勝利！" : "敗北...";
                title.style.color = iAmWinner ? '#22c55e' : '#ef4444';
                rewards.innerHTML = "オンライン対戦終了！";
                cancelMatching(); // Clean up online match data
            }
            else if (battle.playerTotalStats.currentHp > 0) {
                title.textContent = "勝利！";
                title.style.color = '#22c55e';
                const coinsWon = 10 + battle.stage * 2;
                let rewardText = `${coinsWon} コイン獲得！`;
                player.coins += coinsWon;
                if (battle.stage === player.storyProgress) player.storyProgress++;
                
                if (battle.stage % 3 === 0) {
                    let hpLimit = Infinity, atkLimit = Infinity;
                    if (battle.stage <= 10) { hpLimit = 800; atkLimit = 100; }
                    else if (battle.stage <= 20) { hpLimit = 2000; atkLimit = 300; }
                    else if (battle.stage <= 49) { hpLimit = 5000; atkLimit = 500; }
                    
                    // ステージ報酬で手に入るスライムを制限する
                    const rewardPool = allSlimes.filter(s => s.hp <= hpLimit && s.atk <= atkLimit && s.rarity !== 'UR'); // URはステージ報酬からは出ない
                    
                    if (rewardPool.length > 0) {
                        const newSlimeBase = rewardPool[Math.floor(Math.random() * rewardPool.length)];
                        const isOwned = player.slimes.some(s => s.no === newSlimeBase.no);

                        if (!isOwned) {
                           player.slimes.push(createNewSlimeInstance(newSlimeBase));
                           rewardText += `<br>${newSlimeBase.name}が仲間になった！`;
                        } else {
                           let coinReward = 0;
                           switch(newSlimeBase.rarity) {
                                case 'R': coinReward = 3; break;
                                case 'SR': coinReward = 10; break;
                                case 'SSR': coinReward = 25; break;
                                default: coinReward = 1;
                           }
                           player.coins += coinReward;
                           rewardText += `<br>既に仲間の${newSlimeBase.name}だった！<br>${coinReward}コインに変換された！`;
                        }
                    }
                }
                rewards.innerHTML = rewardText;
            } else {
                title.textContent = "敗北...";
                title.style.color = '#ef4444';
                rewards.innerHTML = "再挑戦しよう！";
            }
            saveGame();
            modal.style.display = 'flex';
            gameState.battle = null; // Clear battle state
        }
        
        document.getElementById('result-close-btn').onclick = () => {
            const wasOnline = gameState.battle && gameState.battle.online;
            document.getElementById('battle-result-modal').style.display = 'none';
            showScreen(wasOnline ? 'online-lobby-screen' : 'story-map-screen');
            if (wasOnline) cancelMatching();
        };

        function startMashBattle() {
            const modal = document.getElementById('mash-battle-modal');
            modal.style.display = 'flex';
            let timeLeft = 3, mashCount = 0, ended = false;
            const timerEl = document.getElementById('mash-timer');
            timerEl.textContent = timeLeft;

            const endMash = (result) => {
                if(ended) return;
                ended = true;
                clearInterval(countdown);
                
                if (gameState.battle.online) {
                    // Player 1 is the decider to avoid race conditions
                    if(gameState.battle.isPlayer1){
                       const isWinner = result >= (Math.random() * 10 + 5); // P1 decides winner
                       const opponentUid = gameState.battle.opponentUid;
                       const firstTurnUid = isWinner ? auth.currentUser.uid : opponentUid;
                       updateMatchInFirestore({ turn: firstTurnUid, phase: 'attack' });
                    }
                    // P2 just waits for the update via onSnapshot
                } else {
                    const isWinner = result >= (Math.random() * 15 + 5);
                    gameState.battle.turn = isWinner ? 'player' : 'enemy';
                    setBattleMessage(isWinner ? "あなたの先行！" : "相手の先行！");
                    setTimeout(battleTurn, 1000);
                }
                modal.style.display = 'none';
            };

            const countdown = setInterval(() => {
                timeLeft--;
                timerEl.textContent = timeLeft;
                if (timeLeft <= 0) {
                    endMash(mashCount);
                }
            }, 1000);
            document.getElementById('mash-btn').onclick = () => { if(timeLeft > 0) mashCount++; };
        }

        window.executeReset = () => {
            localStorage.removeItem('slimeWarSave');
            location.reload();
        };
    </script>
</body>
</html>



